
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export interface PrismaPromise<A> extends Promise<A> {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: number
  phone: string
  name: string | null
  password: string
  isDeleted: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Engin
 * 
 */
export type Engin = {
  id: number
  immatriculation: string
  marque: string
  model: string
  statut: number
  isDeleted: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Chauffeur
 * 
 */
export type Chauffeur = {
  id: number
  nom: string
  prenom: string
  contact: string
  adresse: string
  statut: number
  isDeleted: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Position
 * 
 */
export type Position = {
  id: number
  designation: string
  statut: number
  isDeleted: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Pneu
 * 
 */
export type Pneu = {
  id: number
  numero_serie: string
  enginId: number | null
  designation: string
  positionId: number | null
  date_debut: Date
  etat: string
  statut: number
  isDeleted: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Sortie
 * 
 */
export type Sortie = {
  id: number
  date: Date
  pneuId: number | null
  chauffeurId: number | null
  kilometre: number
  motif: string
  statut: number
  isDeleted: boolean
  createdAt: Date
  updatedAt: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.engin`: Exposes CRUD operations for the **Engin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Engins
    * const engins = await prisma.engin.findMany()
    * ```
    */
  get engin(): Prisma.EnginDelegate<GlobalReject>;

  /**
   * `prisma.chauffeur`: Exposes CRUD operations for the **Chauffeur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chauffeurs
    * const chauffeurs = await prisma.chauffeur.findMany()
    * ```
    */
  get chauffeur(): Prisma.ChauffeurDelegate<GlobalReject>;

  /**
   * `prisma.position`: Exposes CRUD operations for the **Position** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.position.findMany()
    * ```
    */
  get position(): Prisma.PositionDelegate<GlobalReject>;

  /**
   * `prisma.pneu`: Exposes CRUD operations for the **Pneu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pneus
    * const pneus = await prisma.pneu.findMany()
    * ```
    */
  get pneu(): Prisma.PneuDelegate<GlobalReject>;

  /**
   * `prisma.sortie`: Exposes CRUD operations for the **Sortie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sorties
    * const sorties = await prisma.sortie.findMany()
    * ```
    */
  get sortie(): Prisma.SortieDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.9.0
   * Query Engine version: ceb5c99003b99c9ee2c1d2e618e359c14aef2ea5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Engin: 'Engin',
    Chauffeur: 'Chauffeur',
    Position: 'Position',
    Pneu: 'Pneu',
    Sortie: 'Sortie'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EnginCountOutputType
   */


  export type EnginCountOutputType = {
    pneus: number
  }

  export type EnginCountOutputTypeSelect = {
    pneus?: boolean
  }

  export type EnginCountOutputTypeGetPayload<S extends boolean | null | undefined | EnginCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EnginCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (EnginCountOutputTypeArgs)
    ? EnginCountOutputType 
    : S extends { select: any } & (EnginCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof EnginCountOutputType ? EnginCountOutputType[P] : never
  } 
      : EnginCountOutputType




  // Custom InputTypes

  /**
   * EnginCountOutputType without action
   */
  export type EnginCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EnginCountOutputType
     */
    select?: EnginCountOutputTypeSelect | null
  }



  /**
   * Count Type ChauffeurCountOutputType
   */


  export type ChauffeurCountOutputType = {
    sorties: number
  }

  export type ChauffeurCountOutputTypeSelect = {
    sorties?: boolean
  }

  export type ChauffeurCountOutputTypeGetPayload<S extends boolean | null | undefined | ChauffeurCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChauffeurCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ChauffeurCountOutputTypeArgs)
    ? ChauffeurCountOutputType 
    : S extends { select: any } & (ChauffeurCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ChauffeurCountOutputType ? ChauffeurCountOutputType[P] : never
  } 
      : ChauffeurCountOutputType




  // Custom InputTypes

  /**
   * ChauffeurCountOutputType without action
   */
  export type ChauffeurCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChauffeurCountOutputType
     */
    select?: ChauffeurCountOutputTypeSelect | null
  }



  /**
   * Count Type PositionCountOutputType
   */


  export type PositionCountOutputType = {
    pneus: number
  }

  export type PositionCountOutputTypeSelect = {
    pneus?: boolean
  }

  export type PositionCountOutputTypeGetPayload<S extends boolean | null | undefined | PositionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PositionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PositionCountOutputTypeArgs)
    ? PositionCountOutputType 
    : S extends { select: any } & (PositionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PositionCountOutputType ? PositionCountOutputType[P] : never
  } 
      : PositionCountOutputType




  // Custom InputTypes

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PositionCountOutputType
     */
    select?: PositionCountOutputTypeSelect | null
  }



  /**
   * Count Type PneuCountOutputType
   */


  export type PneuCountOutputType = {
    sorties: number
  }

  export type PneuCountOutputTypeSelect = {
    sorties?: boolean
  }

  export type PneuCountOutputTypeGetPayload<S extends boolean | null | undefined | PneuCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PneuCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PneuCountOutputTypeArgs)
    ? PneuCountOutputType 
    : S extends { select: any } & (PneuCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PneuCountOutputType ? PneuCountOutputType[P] : never
  } 
      : PneuCountOutputType




  // Custom InputTypes

  /**
   * PneuCountOutputType without action
   */
  export type PneuCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PneuCountOutputType
     */
    select?: PneuCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    phone: string | null
    name: string | null
    password: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    phone: string | null
    name: string | null
    password: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    phone: number
    name: number
    password: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    phone?: true
    name?: true
    password?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    phone?: true
    name?: true
    password?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    phone?: true
    name?: true
    password?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    phone: string
    name: string | null
    password: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    phone?: boolean
    name?: boolean
    password?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
  }



  /**
   * Model Engin
   */


  export type AggregateEngin = {
    _count: EnginCountAggregateOutputType | null
    _avg: EnginAvgAggregateOutputType | null
    _sum: EnginSumAggregateOutputType | null
    _min: EnginMinAggregateOutputType | null
    _max: EnginMaxAggregateOutputType | null
  }

  export type EnginAvgAggregateOutputType = {
    id: number | null
    statut: number | null
  }

  export type EnginSumAggregateOutputType = {
    id: number | null
    statut: number | null
  }

  export type EnginMinAggregateOutputType = {
    id: number | null
    immatriculation: string | null
    marque: string | null
    model: string | null
    statut: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnginMaxAggregateOutputType = {
    id: number | null
    immatriculation: string | null
    marque: string | null
    model: string | null
    statut: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnginCountAggregateOutputType = {
    id: number
    immatriculation: number
    marque: number
    model: number
    statut: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EnginAvgAggregateInputType = {
    id?: true
    statut?: true
  }

  export type EnginSumAggregateInputType = {
    id?: true
    statut?: true
  }

  export type EnginMinAggregateInputType = {
    id?: true
    immatriculation?: true
    marque?: true
    model?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnginMaxAggregateInputType = {
    id?: true
    immatriculation?: true
    marque?: true
    model?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnginCountAggregateInputType = {
    id?: true
    immatriculation?: true
    marque?: true
    model?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EnginAggregateArgs = {
    /**
     * Filter which Engin to aggregate.
     */
    where?: EnginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Engins to fetch.
     */
    orderBy?: Enumerable<EnginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Engins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Engins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Engins
    **/
    _count?: true | EnginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnginMaxAggregateInputType
  }

  export type GetEnginAggregateType<T extends EnginAggregateArgs> = {
        [P in keyof T & keyof AggregateEngin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEngin[P]>
      : GetScalarType<T[P], AggregateEngin[P]>
  }




  export type EnginGroupByArgs = {
    where?: EnginWhereInput
    orderBy?: Enumerable<EnginOrderByWithAggregationInput>
    by: EnginScalarFieldEnum[]
    having?: EnginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnginCountAggregateInputType | true
    _avg?: EnginAvgAggregateInputType
    _sum?: EnginSumAggregateInputType
    _min?: EnginMinAggregateInputType
    _max?: EnginMaxAggregateInputType
  }


  export type EnginGroupByOutputType = {
    id: number
    immatriculation: string
    marque: string
    model: string
    statut: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: EnginCountAggregateOutputType | null
    _avg: EnginAvgAggregateOutputType | null
    _sum: EnginSumAggregateOutputType | null
    _min: EnginMinAggregateOutputType | null
    _max: EnginMaxAggregateOutputType | null
  }

  type GetEnginGroupByPayload<T extends EnginGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EnginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnginGroupByOutputType[P]>
            : GetScalarType<T[P], EnginGroupByOutputType[P]>
        }
      >
    >


  export type EnginSelect = {
    id?: boolean
    immatriculation?: boolean
    marque?: boolean
    model?: boolean
    pneus?: boolean | Engin$pneusArgs
    statut?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | EnginCountOutputTypeArgs
  }


  export type EnginInclude = {
    pneus?: boolean | Engin$pneusArgs
    _count?: boolean | EnginCountOutputTypeArgs
  }

  export type EnginGetPayload<S extends boolean | null | undefined | EnginArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Engin :
    S extends undefined ? never :
    S extends { include: any } & (EnginArgs | EnginFindManyArgs)
    ? Engin  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'pneus' ? Array < PneuGetPayload<S['include'][P]>>  :
        P extends '_count' ? EnginCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (EnginArgs | EnginFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'pneus' ? Array < PneuGetPayload<S['select'][P]>>  :
        P extends '_count' ? EnginCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Engin ? Engin[P] : never
  } 
      : Engin


  type EnginCountArgs = 
    Omit<EnginFindManyArgs, 'select' | 'include'> & {
      select?: EnginCountAggregateInputType | true
    }

  export interface EnginDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Engin that matches the filter.
     * @param {EnginFindUniqueArgs} args - Arguments to find a Engin
     * @example
     * // Get one Engin
     * const engin = await prisma.engin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnginFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EnginFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Engin'> extends True ? Prisma__EnginClient<EnginGetPayload<T>> : Prisma__EnginClient<EnginGetPayload<T> | null, null>

    /**
     * Find one Engin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EnginFindUniqueOrThrowArgs} args - Arguments to find a Engin
     * @example
     * // Get one Engin
     * const engin = await prisma.engin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EnginFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EnginFindUniqueOrThrowArgs>
    ): Prisma__EnginClient<EnginGetPayload<T>>

    /**
     * Find the first Engin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnginFindFirstArgs} args - Arguments to find a Engin
     * @example
     * // Get one Engin
     * const engin = await prisma.engin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnginFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EnginFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Engin'> extends True ? Prisma__EnginClient<EnginGetPayload<T>> : Prisma__EnginClient<EnginGetPayload<T> | null, null>

    /**
     * Find the first Engin that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnginFindFirstOrThrowArgs} args - Arguments to find a Engin
     * @example
     * // Get one Engin
     * const engin = await prisma.engin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EnginFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EnginFindFirstOrThrowArgs>
    ): Prisma__EnginClient<EnginGetPayload<T>>

    /**
     * Find zero or more Engins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnginFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Engins
     * const engins = await prisma.engin.findMany()
     * 
     * // Get first 10 Engins
     * const engins = await prisma.engin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enginWithIdOnly = await prisma.engin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EnginFindManyArgs>(
      args?: SelectSubset<T, EnginFindManyArgs>
    ): PrismaPromise<Array<EnginGetPayload<T>>>

    /**
     * Create a Engin.
     * @param {EnginCreateArgs} args - Arguments to create a Engin.
     * @example
     * // Create one Engin
     * const Engin = await prisma.engin.create({
     *   data: {
     *     // ... data to create a Engin
     *   }
     * })
     * 
    **/
    create<T extends EnginCreateArgs>(
      args: SelectSubset<T, EnginCreateArgs>
    ): Prisma__EnginClient<EnginGetPayload<T>>

    /**
     * Delete a Engin.
     * @param {EnginDeleteArgs} args - Arguments to delete one Engin.
     * @example
     * // Delete one Engin
     * const Engin = await prisma.engin.delete({
     *   where: {
     *     // ... filter to delete one Engin
     *   }
     * })
     * 
    **/
    delete<T extends EnginDeleteArgs>(
      args: SelectSubset<T, EnginDeleteArgs>
    ): Prisma__EnginClient<EnginGetPayload<T>>

    /**
     * Update one Engin.
     * @param {EnginUpdateArgs} args - Arguments to update one Engin.
     * @example
     * // Update one Engin
     * const engin = await prisma.engin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnginUpdateArgs>(
      args: SelectSubset<T, EnginUpdateArgs>
    ): Prisma__EnginClient<EnginGetPayload<T>>

    /**
     * Delete zero or more Engins.
     * @param {EnginDeleteManyArgs} args - Arguments to filter Engins to delete.
     * @example
     * // Delete a few Engins
     * const { count } = await prisma.engin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnginDeleteManyArgs>(
      args?: SelectSubset<T, EnginDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Engins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Engins
     * const engin = await prisma.engin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnginUpdateManyArgs>(
      args: SelectSubset<T, EnginUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Engin.
     * @param {EnginUpsertArgs} args - Arguments to update or create a Engin.
     * @example
     * // Update or create a Engin
     * const engin = await prisma.engin.upsert({
     *   create: {
     *     // ... data to create a Engin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Engin we want to update
     *   }
     * })
    **/
    upsert<T extends EnginUpsertArgs>(
      args: SelectSubset<T, EnginUpsertArgs>
    ): Prisma__EnginClient<EnginGetPayload<T>>

    /**
     * Count the number of Engins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnginCountArgs} args - Arguments to filter Engins to count.
     * @example
     * // Count the number of Engins
     * const count = await prisma.engin.count({
     *   where: {
     *     // ... the filter for the Engins we want to count
     *   }
     * })
    **/
    count<T extends EnginCountArgs>(
      args?: Subset<T, EnginCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Engin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnginAggregateArgs>(args: Subset<T, EnginAggregateArgs>): PrismaPromise<GetEnginAggregateType<T>>

    /**
     * Group by Engin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnginGroupByArgs['orderBy'] }
        : { orderBy?: EnginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnginGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Engin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EnginClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pneus<T extends Engin$pneusArgs= {}>(args?: Subset<T, Engin$pneusArgs>): PrismaPromise<Array<PneuGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Engin base type for findUnique actions
   */
  export type EnginFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Engin
     */
    select?: EnginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnginInclude | null
    /**
     * Filter, which Engin to fetch.
     */
    where: EnginWhereUniqueInput
  }

  /**
   * Engin findUnique
   */
  export interface EnginFindUniqueArgs extends EnginFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Engin findUniqueOrThrow
   */
  export type EnginFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Engin
     */
    select?: EnginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnginInclude | null
    /**
     * Filter, which Engin to fetch.
     */
    where: EnginWhereUniqueInput
  }


  /**
   * Engin base type for findFirst actions
   */
  export type EnginFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Engin
     */
    select?: EnginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnginInclude | null
    /**
     * Filter, which Engin to fetch.
     */
    where?: EnginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Engins to fetch.
     */
    orderBy?: Enumerable<EnginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Engins.
     */
    cursor?: EnginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Engins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Engins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Engins.
     */
    distinct?: Enumerable<EnginScalarFieldEnum>
  }

  /**
   * Engin findFirst
   */
  export interface EnginFindFirstArgs extends EnginFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Engin findFirstOrThrow
   */
  export type EnginFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Engin
     */
    select?: EnginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnginInclude | null
    /**
     * Filter, which Engin to fetch.
     */
    where?: EnginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Engins to fetch.
     */
    orderBy?: Enumerable<EnginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Engins.
     */
    cursor?: EnginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Engins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Engins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Engins.
     */
    distinct?: Enumerable<EnginScalarFieldEnum>
  }


  /**
   * Engin findMany
   */
  export type EnginFindManyArgs = {
    /**
     * Select specific fields to fetch from the Engin
     */
    select?: EnginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnginInclude | null
    /**
     * Filter, which Engins to fetch.
     */
    where?: EnginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Engins to fetch.
     */
    orderBy?: Enumerable<EnginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Engins.
     */
    cursor?: EnginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Engins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Engins.
     */
    skip?: number
    distinct?: Enumerable<EnginScalarFieldEnum>
  }


  /**
   * Engin create
   */
  export type EnginCreateArgs = {
    /**
     * Select specific fields to fetch from the Engin
     */
    select?: EnginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnginInclude | null
    /**
     * The data needed to create a Engin.
     */
    data: XOR<EnginCreateInput, EnginUncheckedCreateInput>
  }


  /**
   * Engin update
   */
  export type EnginUpdateArgs = {
    /**
     * Select specific fields to fetch from the Engin
     */
    select?: EnginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnginInclude | null
    /**
     * The data needed to update a Engin.
     */
    data: XOR<EnginUpdateInput, EnginUncheckedUpdateInput>
    /**
     * Choose, which Engin to update.
     */
    where: EnginWhereUniqueInput
  }


  /**
   * Engin updateMany
   */
  export type EnginUpdateManyArgs = {
    /**
     * The data used to update Engins.
     */
    data: XOR<EnginUpdateManyMutationInput, EnginUncheckedUpdateManyInput>
    /**
     * Filter which Engins to update
     */
    where?: EnginWhereInput
  }


  /**
   * Engin upsert
   */
  export type EnginUpsertArgs = {
    /**
     * Select specific fields to fetch from the Engin
     */
    select?: EnginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnginInclude | null
    /**
     * The filter to search for the Engin to update in case it exists.
     */
    where: EnginWhereUniqueInput
    /**
     * In case the Engin found by the `where` argument doesn't exist, create a new Engin with this data.
     */
    create: XOR<EnginCreateInput, EnginUncheckedCreateInput>
    /**
     * In case the Engin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnginUpdateInput, EnginUncheckedUpdateInput>
  }


  /**
   * Engin delete
   */
  export type EnginDeleteArgs = {
    /**
     * Select specific fields to fetch from the Engin
     */
    select?: EnginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnginInclude | null
    /**
     * Filter which Engin to delete.
     */
    where: EnginWhereUniqueInput
  }


  /**
   * Engin deleteMany
   */
  export type EnginDeleteManyArgs = {
    /**
     * Filter which Engins to delete
     */
    where?: EnginWhereInput
  }


  /**
   * Engin.pneus
   */
  export type Engin$pneusArgs = {
    /**
     * Select specific fields to fetch from the Pneu
     */
    select?: PneuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PneuInclude | null
    where?: PneuWhereInput
    orderBy?: Enumerable<PneuOrderByWithRelationInput>
    cursor?: PneuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PneuScalarFieldEnum>
  }


  /**
   * Engin without action
   */
  export type EnginArgs = {
    /**
     * Select specific fields to fetch from the Engin
     */
    select?: EnginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnginInclude | null
  }



  /**
   * Model Chauffeur
   */


  export type AggregateChauffeur = {
    _count: ChauffeurCountAggregateOutputType | null
    _avg: ChauffeurAvgAggregateOutputType | null
    _sum: ChauffeurSumAggregateOutputType | null
    _min: ChauffeurMinAggregateOutputType | null
    _max: ChauffeurMaxAggregateOutputType | null
  }

  export type ChauffeurAvgAggregateOutputType = {
    id: number | null
    statut: number | null
  }

  export type ChauffeurSumAggregateOutputType = {
    id: number | null
    statut: number | null
  }

  export type ChauffeurMinAggregateOutputType = {
    id: number | null
    nom: string | null
    prenom: string | null
    contact: string | null
    adresse: string | null
    statut: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChauffeurMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    prenom: string | null
    contact: string | null
    adresse: string | null
    statut: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChauffeurCountAggregateOutputType = {
    id: number
    nom: number
    prenom: number
    contact: number
    adresse: number
    statut: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChauffeurAvgAggregateInputType = {
    id?: true
    statut?: true
  }

  export type ChauffeurSumAggregateInputType = {
    id?: true
    statut?: true
  }

  export type ChauffeurMinAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    contact?: true
    adresse?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChauffeurMaxAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    contact?: true
    adresse?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChauffeurCountAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    contact?: true
    adresse?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChauffeurAggregateArgs = {
    /**
     * Filter which Chauffeur to aggregate.
     */
    where?: ChauffeurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chauffeurs to fetch.
     */
    orderBy?: Enumerable<ChauffeurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChauffeurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chauffeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chauffeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chauffeurs
    **/
    _count?: true | ChauffeurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChauffeurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChauffeurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChauffeurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChauffeurMaxAggregateInputType
  }

  export type GetChauffeurAggregateType<T extends ChauffeurAggregateArgs> = {
        [P in keyof T & keyof AggregateChauffeur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChauffeur[P]>
      : GetScalarType<T[P], AggregateChauffeur[P]>
  }




  export type ChauffeurGroupByArgs = {
    where?: ChauffeurWhereInput
    orderBy?: Enumerable<ChauffeurOrderByWithAggregationInput>
    by: ChauffeurScalarFieldEnum[]
    having?: ChauffeurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChauffeurCountAggregateInputType | true
    _avg?: ChauffeurAvgAggregateInputType
    _sum?: ChauffeurSumAggregateInputType
    _min?: ChauffeurMinAggregateInputType
    _max?: ChauffeurMaxAggregateInputType
  }


  export type ChauffeurGroupByOutputType = {
    id: number
    nom: string
    prenom: string
    contact: string
    adresse: string
    statut: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ChauffeurCountAggregateOutputType | null
    _avg: ChauffeurAvgAggregateOutputType | null
    _sum: ChauffeurSumAggregateOutputType | null
    _min: ChauffeurMinAggregateOutputType | null
    _max: ChauffeurMaxAggregateOutputType | null
  }

  type GetChauffeurGroupByPayload<T extends ChauffeurGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ChauffeurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChauffeurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChauffeurGroupByOutputType[P]>
            : GetScalarType<T[P], ChauffeurGroupByOutputType[P]>
        }
      >
    >


  export type ChauffeurSelect = {
    id?: boolean
    nom?: boolean
    prenom?: boolean
    contact?: boolean
    adresse?: boolean
    sorties?: boolean | Chauffeur$sortiesArgs
    statut?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ChauffeurCountOutputTypeArgs
  }


  export type ChauffeurInclude = {
    sorties?: boolean | Chauffeur$sortiesArgs
    _count?: boolean | ChauffeurCountOutputTypeArgs
  }

  export type ChauffeurGetPayload<S extends boolean | null | undefined | ChauffeurArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Chauffeur :
    S extends undefined ? never :
    S extends { include: any } & (ChauffeurArgs | ChauffeurFindManyArgs)
    ? Chauffeur  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'sorties' ? Array < SortieGetPayload<S['include'][P]>>  :
        P extends '_count' ? ChauffeurCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChauffeurArgs | ChauffeurFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'sorties' ? Array < SortieGetPayload<S['select'][P]>>  :
        P extends '_count' ? ChauffeurCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Chauffeur ? Chauffeur[P] : never
  } 
      : Chauffeur


  type ChauffeurCountArgs = 
    Omit<ChauffeurFindManyArgs, 'select' | 'include'> & {
      select?: ChauffeurCountAggregateInputType | true
    }

  export interface ChauffeurDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Chauffeur that matches the filter.
     * @param {ChauffeurFindUniqueArgs} args - Arguments to find a Chauffeur
     * @example
     * // Get one Chauffeur
     * const chauffeur = await prisma.chauffeur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChauffeurFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChauffeurFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Chauffeur'> extends True ? Prisma__ChauffeurClient<ChauffeurGetPayload<T>> : Prisma__ChauffeurClient<ChauffeurGetPayload<T> | null, null>

    /**
     * Find one Chauffeur that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChauffeurFindUniqueOrThrowArgs} args - Arguments to find a Chauffeur
     * @example
     * // Get one Chauffeur
     * const chauffeur = await prisma.chauffeur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChauffeurFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChauffeurFindUniqueOrThrowArgs>
    ): Prisma__ChauffeurClient<ChauffeurGetPayload<T>>

    /**
     * Find the first Chauffeur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChauffeurFindFirstArgs} args - Arguments to find a Chauffeur
     * @example
     * // Get one Chauffeur
     * const chauffeur = await prisma.chauffeur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChauffeurFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChauffeurFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Chauffeur'> extends True ? Prisma__ChauffeurClient<ChauffeurGetPayload<T>> : Prisma__ChauffeurClient<ChauffeurGetPayload<T> | null, null>

    /**
     * Find the first Chauffeur that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChauffeurFindFirstOrThrowArgs} args - Arguments to find a Chauffeur
     * @example
     * // Get one Chauffeur
     * const chauffeur = await prisma.chauffeur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChauffeurFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChauffeurFindFirstOrThrowArgs>
    ): Prisma__ChauffeurClient<ChauffeurGetPayload<T>>

    /**
     * Find zero or more Chauffeurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChauffeurFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chauffeurs
     * const chauffeurs = await prisma.chauffeur.findMany()
     * 
     * // Get first 10 Chauffeurs
     * const chauffeurs = await prisma.chauffeur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chauffeurWithIdOnly = await prisma.chauffeur.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChauffeurFindManyArgs>(
      args?: SelectSubset<T, ChauffeurFindManyArgs>
    ): PrismaPromise<Array<ChauffeurGetPayload<T>>>

    /**
     * Create a Chauffeur.
     * @param {ChauffeurCreateArgs} args - Arguments to create a Chauffeur.
     * @example
     * // Create one Chauffeur
     * const Chauffeur = await prisma.chauffeur.create({
     *   data: {
     *     // ... data to create a Chauffeur
     *   }
     * })
     * 
    **/
    create<T extends ChauffeurCreateArgs>(
      args: SelectSubset<T, ChauffeurCreateArgs>
    ): Prisma__ChauffeurClient<ChauffeurGetPayload<T>>

    /**
     * Delete a Chauffeur.
     * @param {ChauffeurDeleteArgs} args - Arguments to delete one Chauffeur.
     * @example
     * // Delete one Chauffeur
     * const Chauffeur = await prisma.chauffeur.delete({
     *   where: {
     *     // ... filter to delete one Chauffeur
     *   }
     * })
     * 
    **/
    delete<T extends ChauffeurDeleteArgs>(
      args: SelectSubset<T, ChauffeurDeleteArgs>
    ): Prisma__ChauffeurClient<ChauffeurGetPayload<T>>

    /**
     * Update one Chauffeur.
     * @param {ChauffeurUpdateArgs} args - Arguments to update one Chauffeur.
     * @example
     * // Update one Chauffeur
     * const chauffeur = await prisma.chauffeur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChauffeurUpdateArgs>(
      args: SelectSubset<T, ChauffeurUpdateArgs>
    ): Prisma__ChauffeurClient<ChauffeurGetPayload<T>>

    /**
     * Delete zero or more Chauffeurs.
     * @param {ChauffeurDeleteManyArgs} args - Arguments to filter Chauffeurs to delete.
     * @example
     * // Delete a few Chauffeurs
     * const { count } = await prisma.chauffeur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChauffeurDeleteManyArgs>(
      args?: SelectSubset<T, ChauffeurDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chauffeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChauffeurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chauffeurs
     * const chauffeur = await prisma.chauffeur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChauffeurUpdateManyArgs>(
      args: SelectSubset<T, ChauffeurUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Chauffeur.
     * @param {ChauffeurUpsertArgs} args - Arguments to update or create a Chauffeur.
     * @example
     * // Update or create a Chauffeur
     * const chauffeur = await prisma.chauffeur.upsert({
     *   create: {
     *     // ... data to create a Chauffeur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chauffeur we want to update
     *   }
     * })
    **/
    upsert<T extends ChauffeurUpsertArgs>(
      args: SelectSubset<T, ChauffeurUpsertArgs>
    ): Prisma__ChauffeurClient<ChauffeurGetPayload<T>>

    /**
     * Count the number of Chauffeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChauffeurCountArgs} args - Arguments to filter Chauffeurs to count.
     * @example
     * // Count the number of Chauffeurs
     * const count = await prisma.chauffeur.count({
     *   where: {
     *     // ... the filter for the Chauffeurs we want to count
     *   }
     * })
    **/
    count<T extends ChauffeurCountArgs>(
      args?: Subset<T, ChauffeurCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChauffeurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chauffeur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChauffeurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChauffeurAggregateArgs>(args: Subset<T, ChauffeurAggregateArgs>): PrismaPromise<GetChauffeurAggregateType<T>>

    /**
     * Group by Chauffeur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChauffeurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChauffeurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChauffeurGroupByArgs['orderBy'] }
        : { orderBy?: ChauffeurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChauffeurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChauffeurGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Chauffeur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChauffeurClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    sorties<T extends Chauffeur$sortiesArgs= {}>(args?: Subset<T, Chauffeur$sortiesArgs>): PrismaPromise<Array<SortieGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Chauffeur base type for findUnique actions
   */
  export type ChauffeurFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Chauffeur
     */
    select?: ChauffeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChauffeurInclude | null
    /**
     * Filter, which Chauffeur to fetch.
     */
    where: ChauffeurWhereUniqueInput
  }

  /**
   * Chauffeur findUnique
   */
  export interface ChauffeurFindUniqueArgs extends ChauffeurFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Chauffeur findUniqueOrThrow
   */
  export type ChauffeurFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Chauffeur
     */
    select?: ChauffeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChauffeurInclude | null
    /**
     * Filter, which Chauffeur to fetch.
     */
    where: ChauffeurWhereUniqueInput
  }


  /**
   * Chauffeur base type for findFirst actions
   */
  export type ChauffeurFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Chauffeur
     */
    select?: ChauffeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChauffeurInclude | null
    /**
     * Filter, which Chauffeur to fetch.
     */
    where?: ChauffeurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chauffeurs to fetch.
     */
    orderBy?: Enumerable<ChauffeurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chauffeurs.
     */
    cursor?: ChauffeurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chauffeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chauffeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chauffeurs.
     */
    distinct?: Enumerable<ChauffeurScalarFieldEnum>
  }

  /**
   * Chauffeur findFirst
   */
  export interface ChauffeurFindFirstArgs extends ChauffeurFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Chauffeur findFirstOrThrow
   */
  export type ChauffeurFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Chauffeur
     */
    select?: ChauffeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChauffeurInclude | null
    /**
     * Filter, which Chauffeur to fetch.
     */
    where?: ChauffeurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chauffeurs to fetch.
     */
    orderBy?: Enumerable<ChauffeurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chauffeurs.
     */
    cursor?: ChauffeurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chauffeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chauffeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chauffeurs.
     */
    distinct?: Enumerable<ChauffeurScalarFieldEnum>
  }


  /**
   * Chauffeur findMany
   */
  export type ChauffeurFindManyArgs = {
    /**
     * Select specific fields to fetch from the Chauffeur
     */
    select?: ChauffeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChauffeurInclude | null
    /**
     * Filter, which Chauffeurs to fetch.
     */
    where?: ChauffeurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chauffeurs to fetch.
     */
    orderBy?: Enumerable<ChauffeurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chauffeurs.
     */
    cursor?: ChauffeurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chauffeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chauffeurs.
     */
    skip?: number
    distinct?: Enumerable<ChauffeurScalarFieldEnum>
  }


  /**
   * Chauffeur create
   */
  export type ChauffeurCreateArgs = {
    /**
     * Select specific fields to fetch from the Chauffeur
     */
    select?: ChauffeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChauffeurInclude | null
    /**
     * The data needed to create a Chauffeur.
     */
    data: XOR<ChauffeurCreateInput, ChauffeurUncheckedCreateInput>
  }


  /**
   * Chauffeur update
   */
  export type ChauffeurUpdateArgs = {
    /**
     * Select specific fields to fetch from the Chauffeur
     */
    select?: ChauffeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChauffeurInclude | null
    /**
     * The data needed to update a Chauffeur.
     */
    data: XOR<ChauffeurUpdateInput, ChauffeurUncheckedUpdateInput>
    /**
     * Choose, which Chauffeur to update.
     */
    where: ChauffeurWhereUniqueInput
  }


  /**
   * Chauffeur updateMany
   */
  export type ChauffeurUpdateManyArgs = {
    /**
     * The data used to update Chauffeurs.
     */
    data: XOR<ChauffeurUpdateManyMutationInput, ChauffeurUncheckedUpdateManyInput>
    /**
     * Filter which Chauffeurs to update
     */
    where?: ChauffeurWhereInput
  }


  /**
   * Chauffeur upsert
   */
  export type ChauffeurUpsertArgs = {
    /**
     * Select specific fields to fetch from the Chauffeur
     */
    select?: ChauffeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChauffeurInclude | null
    /**
     * The filter to search for the Chauffeur to update in case it exists.
     */
    where: ChauffeurWhereUniqueInput
    /**
     * In case the Chauffeur found by the `where` argument doesn't exist, create a new Chauffeur with this data.
     */
    create: XOR<ChauffeurCreateInput, ChauffeurUncheckedCreateInput>
    /**
     * In case the Chauffeur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChauffeurUpdateInput, ChauffeurUncheckedUpdateInput>
  }


  /**
   * Chauffeur delete
   */
  export type ChauffeurDeleteArgs = {
    /**
     * Select specific fields to fetch from the Chauffeur
     */
    select?: ChauffeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChauffeurInclude | null
    /**
     * Filter which Chauffeur to delete.
     */
    where: ChauffeurWhereUniqueInput
  }


  /**
   * Chauffeur deleteMany
   */
  export type ChauffeurDeleteManyArgs = {
    /**
     * Filter which Chauffeurs to delete
     */
    where?: ChauffeurWhereInput
  }


  /**
   * Chauffeur.sorties
   */
  export type Chauffeur$sortiesArgs = {
    /**
     * Select specific fields to fetch from the Sortie
     */
    select?: SortieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SortieInclude | null
    where?: SortieWhereInput
    orderBy?: Enumerable<SortieOrderByWithRelationInput>
    cursor?: SortieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SortieScalarFieldEnum>
  }


  /**
   * Chauffeur without action
   */
  export type ChauffeurArgs = {
    /**
     * Select specific fields to fetch from the Chauffeur
     */
    select?: ChauffeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChauffeurInclude | null
  }



  /**
   * Model Position
   */


  export type AggregatePosition = {
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  export type PositionAvgAggregateOutputType = {
    id: number | null
    statut: number | null
  }

  export type PositionSumAggregateOutputType = {
    id: number | null
    statut: number | null
  }

  export type PositionMinAggregateOutputType = {
    id: number | null
    designation: string | null
    statut: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionMaxAggregateOutputType = {
    id: number | null
    designation: string | null
    statut: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionCountAggregateOutputType = {
    id: number
    designation: number
    statut: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PositionAvgAggregateInputType = {
    id?: true
    statut?: true
  }

  export type PositionSumAggregateInputType = {
    id?: true
    statut?: true
  }

  export type PositionMinAggregateInputType = {
    id?: true
    designation?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionMaxAggregateInputType = {
    id?: true
    designation?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionCountAggregateInputType = {
    id?: true
    designation?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PositionAggregateArgs = {
    /**
     * Filter which Position to aggregate.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: Enumerable<PositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Positions
    **/
    _count?: true | PositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionMaxAggregateInputType
  }

  export type GetPositionAggregateType<T extends PositionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosition[P]>
      : GetScalarType<T[P], AggregatePosition[P]>
  }




  export type PositionGroupByArgs = {
    where?: PositionWhereInput
    orderBy?: Enumerable<PositionOrderByWithAggregationInput>
    by: PositionScalarFieldEnum[]
    having?: PositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionCountAggregateInputType | true
    _avg?: PositionAvgAggregateInputType
    _sum?: PositionSumAggregateInputType
    _min?: PositionMinAggregateInputType
    _max?: PositionMaxAggregateInputType
  }


  export type PositionGroupByOutputType = {
    id: number
    designation: string
    statut: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  type GetPositionGroupByPayload<T extends PositionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionGroupByOutputType[P]>
            : GetScalarType<T[P], PositionGroupByOutputType[P]>
        }
      >
    >


  export type PositionSelect = {
    id?: boolean
    designation?: boolean
    pneus?: boolean | Position$pneusArgs
    statut?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | PositionCountOutputTypeArgs
  }


  export type PositionInclude = {
    pneus?: boolean | Position$pneusArgs
    _count?: boolean | PositionCountOutputTypeArgs
  }

  export type PositionGetPayload<S extends boolean | null | undefined | PositionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Position :
    S extends undefined ? never :
    S extends { include: any } & (PositionArgs | PositionFindManyArgs)
    ? Position  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'pneus' ? Array < PneuGetPayload<S['include'][P]>>  :
        P extends '_count' ? PositionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PositionArgs | PositionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'pneus' ? Array < PneuGetPayload<S['select'][P]>>  :
        P extends '_count' ? PositionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Position ? Position[P] : never
  } 
      : Position


  type PositionCountArgs = 
    Omit<PositionFindManyArgs, 'select' | 'include'> & {
      select?: PositionCountAggregateInputType | true
    }

  export interface PositionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Position that matches the filter.
     * @param {PositionFindUniqueArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PositionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PositionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Position'> extends True ? Prisma__PositionClient<PositionGetPayload<T>> : Prisma__PositionClient<PositionGetPayload<T> | null, null>

    /**
     * Find one Position that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PositionFindUniqueOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PositionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PositionFindUniqueOrThrowArgs>
    ): Prisma__PositionClient<PositionGetPayload<T>>

    /**
     * Find the first Position that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PositionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PositionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Position'> extends True ? Prisma__PositionClient<PositionGetPayload<T>> : Prisma__PositionClient<PositionGetPayload<T> | null, null>

    /**
     * Find the first Position that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PositionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PositionFindFirstOrThrowArgs>
    ): Prisma__PositionClient<PositionGetPayload<T>>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.position.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.position.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionWithIdOnly = await prisma.position.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PositionFindManyArgs>(
      args?: SelectSubset<T, PositionFindManyArgs>
    ): PrismaPromise<Array<PositionGetPayload<T>>>

    /**
     * Create a Position.
     * @param {PositionCreateArgs} args - Arguments to create a Position.
     * @example
     * // Create one Position
     * const Position = await prisma.position.create({
     *   data: {
     *     // ... data to create a Position
     *   }
     * })
     * 
    **/
    create<T extends PositionCreateArgs>(
      args: SelectSubset<T, PositionCreateArgs>
    ): Prisma__PositionClient<PositionGetPayload<T>>

    /**
     * Delete a Position.
     * @param {PositionDeleteArgs} args - Arguments to delete one Position.
     * @example
     * // Delete one Position
     * const Position = await prisma.position.delete({
     *   where: {
     *     // ... filter to delete one Position
     *   }
     * })
     * 
    **/
    delete<T extends PositionDeleteArgs>(
      args: SelectSubset<T, PositionDeleteArgs>
    ): Prisma__PositionClient<PositionGetPayload<T>>

    /**
     * Update one Position.
     * @param {PositionUpdateArgs} args - Arguments to update one Position.
     * @example
     * // Update one Position
     * const position = await prisma.position.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PositionUpdateArgs>(
      args: SelectSubset<T, PositionUpdateArgs>
    ): Prisma__PositionClient<PositionGetPayload<T>>

    /**
     * Delete zero or more Positions.
     * @param {PositionDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.position.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PositionDeleteManyArgs>(
      args?: SelectSubset<T, PositionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PositionUpdateManyArgs>(
      args: SelectSubset<T, PositionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Position.
     * @param {PositionUpsertArgs} args - Arguments to update or create a Position.
     * @example
     * // Update or create a Position
     * const position = await prisma.position.upsert({
     *   create: {
     *     // ... data to create a Position
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Position we want to update
     *   }
     * })
    **/
    upsert<T extends PositionUpsertArgs>(
      args: SelectSubset<T, PositionUpsertArgs>
    ): Prisma__PositionClient<PositionGetPayload<T>>

    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.position.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends PositionCountArgs>(
      args?: Subset<T, PositionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionAggregateArgs>(args: Subset<T, PositionAggregateArgs>): PrismaPromise<GetPositionAggregateType<T>>

    /**
     * Group by Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionGroupByArgs['orderBy'] }
        : { orderBy?: PositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Position.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PositionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pneus<T extends Position$pneusArgs= {}>(args?: Subset<T, Position$pneusArgs>): PrismaPromise<Array<PneuGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Position base type for findUnique actions
   */
  export type PositionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findUnique
   */
  export interface PositionFindUniqueArgs extends PositionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Position findUniqueOrThrow
   */
  export type PositionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }


  /**
   * Position base type for findFirst actions
   */
  export type PositionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: Enumerable<PositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: Enumerable<PositionScalarFieldEnum>
  }

  /**
   * Position findFirst
   */
  export interface PositionFindFirstArgs extends PositionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Position findFirstOrThrow
   */
  export type PositionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: Enumerable<PositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: Enumerable<PositionScalarFieldEnum>
  }


  /**
   * Position findMany
   */
  export type PositionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * Filter, which Positions to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: Enumerable<PositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    distinct?: Enumerable<PositionScalarFieldEnum>
  }


  /**
   * Position create
   */
  export type PositionCreateArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * The data needed to create a Position.
     */
    data: XOR<PositionCreateInput, PositionUncheckedCreateInput>
  }


  /**
   * Position update
   */
  export type PositionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * The data needed to update a Position.
     */
    data: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
    /**
     * Choose, which Position to update.
     */
    where: PositionWhereUniqueInput
  }


  /**
   * Position updateMany
   */
  export type PositionUpdateManyArgs = {
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
  }


  /**
   * Position upsert
   */
  export type PositionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * The filter to search for the Position to update in case it exists.
     */
    where: PositionWhereUniqueInput
    /**
     * In case the Position found by the `where` argument doesn't exist, create a new Position with this data.
     */
    create: XOR<PositionCreateInput, PositionUncheckedCreateInput>
    /**
     * In case the Position was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
  }


  /**
   * Position delete
   */
  export type PositionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * Filter which Position to delete.
     */
    where: PositionWhereUniqueInput
  }


  /**
   * Position deleteMany
   */
  export type PositionDeleteManyArgs = {
    /**
     * Filter which Positions to delete
     */
    where?: PositionWhereInput
  }


  /**
   * Position.pneus
   */
  export type Position$pneusArgs = {
    /**
     * Select specific fields to fetch from the Pneu
     */
    select?: PneuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PneuInclude | null
    where?: PneuWhereInput
    orderBy?: Enumerable<PneuOrderByWithRelationInput>
    cursor?: PneuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PneuScalarFieldEnum>
  }


  /**
   * Position without action
   */
  export type PositionArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
  }



  /**
   * Model Pneu
   */


  export type AggregatePneu = {
    _count: PneuCountAggregateOutputType | null
    _avg: PneuAvgAggregateOutputType | null
    _sum: PneuSumAggregateOutputType | null
    _min: PneuMinAggregateOutputType | null
    _max: PneuMaxAggregateOutputType | null
  }

  export type PneuAvgAggregateOutputType = {
    id: number | null
    enginId: number | null
    positionId: number | null
    statut: number | null
  }

  export type PneuSumAggregateOutputType = {
    id: number | null
    enginId: number | null
    positionId: number | null
    statut: number | null
  }

  export type PneuMinAggregateOutputType = {
    id: number | null
    numero_serie: string | null
    enginId: number | null
    designation: string | null
    positionId: number | null
    date_debut: Date | null
    etat: string | null
    statut: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PneuMaxAggregateOutputType = {
    id: number | null
    numero_serie: string | null
    enginId: number | null
    designation: string | null
    positionId: number | null
    date_debut: Date | null
    etat: string | null
    statut: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PneuCountAggregateOutputType = {
    id: number
    numero_serie: number
    enginId: number
    designation: number
    positionId: number
    date_debut: number
    etat: number
    statut: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PneuAvgAggregateInputType = {
    id?: true
    enginId?: true
    positionId?: true
    statut?: true
  }

  export type PneuSumAggregateInputType = {
    id?: true
    enginId?: true
    positionId?: true
    statut?: true
  }

  export type PneuMinAggregateInputType = {
    id?: true
    numero_serie?: true
    enginId?: true
    designation?: true
    positionId?: true
    date_debut?: true
    etat?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PneuMaxAggregateInputType = {
    id?: true
    numero_serie?: true
    enginId?: true
    designation?: true
    positionId?: true
    date_debut?: true
    etat?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PneuCountAggregateInputType = {
    id?: true
    numero_serie?: true
    enginId?: true
    designation?: true
    positionId?: true
    date_debut?: true
    etat?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PneuAggregateArgs = {
    /**
     * Filter which Pneu to aggregate.
     */
    where?: PneuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pneus to fetch.
     */
    orderBy?: Enumerable<PneuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PneuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pneus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pneus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pneus
    **/
    _count?: true | PneuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PneuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PneuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PneuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PneuMaxAggregateInputType
  }

  export type GetPneuAggregateType<T extends PneuAggregateArgs> = {
        [P in keyof T & keyof AggregatePneu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePneu[P]>
      : GetScalarType<T[P], AggregatePneu[P]>
  }




  export type PneuGroupByArgs = {
    where?: PneuWhereInput
    orderBy?: Enumerable<PneuOrderByWithAggregationInput>
    by: PneuScalarFieldEnum[]
    having?: PneuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PneuCountAggregateInputType | true
    _avg?: PneuAvgAggregateInputType
    _sum?: PneuSumAggregateInputType
    _min?: PneuMinAggregateInputType
    _max?: PneuMaxAggregateInputType
  }


  export type PneuGroupByOutputType = {
    id: number
    numero_serie: string
    enginId: number | null
    designation: string
    positionId: number | null
    date_debut: Date
    etat: string
    statut: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: PneuCountAggregateOutputType | null
    _avg: PneuAvgAggregateOutputType | null
    _sum: PneuSumAggregateOutputType | null
    _min: PneuMinAggregateOutputType | null
    _max: PneuMaxAggregateOutputType | null
  }

  type GetPneuGroupByPayload<T extends PneuGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PneuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PneuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PneuGroupByOutputType[P]>
            : GetScalarType<T[P], PneuGroupByOutputType[P]>
        }
      >
    >


  export type PneuSelect = {
    id?: boolean
    numero_serie?: boolean
    engin?: boolean | EnginArgs
    enginId?: boolean
    designation?: boolean
    position?: boolean | PositionArgs
    positionId?: boolean
    date_debut?: boolean
    sorties?: boolean | Pneu$sortiesArgs
    etat?: boolean
    statut?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | PneuCountOutputTypeArgs
  }


  export type PneuInclude = {
    engin?: boolean | EnginArgs
    position?: boolean | PositionArgs
    sorties?: boolean | Pneu$sortiesArgs
    _count?: boolean | PneuCountOutputTypeArgs
  }

  export type PneuGetPayload<S extends boolean | null | undefined | PneuArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Pneu :
    S extends undefined ? never :
    S extends { include: any } & (PneuArgs | PneuFindManyArgs)
    ? Pneu  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'engin' ? EnginGetPayload<S['include'][P]> | null :
        P extends 'position' ? PositionGetPayload<S['include'][P]> | null :
        P extends 'sorties' ? Array < SortieGetPayload<S['include'][P]>>  :
        P extends '_count' ? PneuCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PneuArgs | PneuFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'engin' ? EnginGetPayload<S['select'][P]> | null :
        P extends 'position' ? PositionGetPayload<S['select'][P]> | null :
        P extends 'sorties' ? Array < SortieGetPayload<S['select'][P]>>  :
        P extends '_count' ? PneuCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Pneu ? Pneu[P] : never
  } 
      : Pneu


  type PneuCountArgs = 
    Omit<PneuFindManyArgs, 'select' | 'include'> & {
      select?: PneuCountAggregateInputType | true
    }

  export interface PneuDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Pneu that matches the filter.
     * @param {PneuFindUniqueArgs} args - Arguments to find a Pneu
     * @example
     * // Get one Pneu
     * const pneu = await prisma.pneu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PneuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PneuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pneu'> extends True ? Prisma__PneuClient<PneuGetPayload<T>> : Prisma__PneuClient<PneuGetPayload<T> | null, null>

    /**
     * Find one Pneu that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PneuFindUniqueOrThrowArgs} args - Arguments to find a Pneu
     * @example
     * // Get one Pneu
     * const pneu = await prisma.pneu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PneuFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PneuFindUniqueOrThrowArgs>
    ): Prisma__PneuClient<PneuGetPayload<T>>

    /**
     * Find the first Pneu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PneuFindFirstArgs} args - Arguments to find a Pneu
     * @example
     * // Get one Pneu
     * const pneu = await prisma.pneu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PneuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PneuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pneu'> extends True ? Prisma__PneuClient<PneuGetPayload<T>> : Prisma__PneuClient<PneuGetPayload<T> | null, null>

    /**
     * Find the first Pneu that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PneuFindFirstOrThrowArgs} args - Arguments to find a Pneu
     * @example
     * // Get one Pneu
     * const pneu = await prisma.pneu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PneuFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PneuFindFirstOrThrowArgs>
    ): Prisma__PneuClient<PneuGetPayload<T>>

    /**
     * Find zero or more Pneus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PneuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pneus
     * const pneus = await prisma.pneu.findMany()
     * 
     * // Get first 10 Pneus
     * const pneus = await prisma.pneu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pneuWithIdOnly = await prisma.pneu.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PneuFindManyArgs>(
      args?: SelectSubset<T, PneuFindManyArgs>
    ): PrismaPromise<Array<PneuGetPayload<T>>>

    /**
     * Create a Pneu.
     * @param {PneuCreateArgs} args - Arguments to create a Pneu.
     * @example
     * // Create one Pneu
     * const Pneu = await prisma.pneu.create({
     *   data: {
     *     // ... data to create a Pneu
     *   }
     * })
     * 
    **/
    create<T extends PneuCreateArgs>(
      args: SelectSubset<T, PneuCreateArgs>
    ): Prisma__PneuClient<PneuGetPayload<T>>

    /**
     * Delete a Pneu.
     * @param {PneuDeleteArgs} args - Arguments to delete one Pneu.
     * @example
     * // Delete one Pneu
     * const Pneu = await prisma.pneu.delete({
     *   where: {
     *     // ... filter to delete one Pneu
     *   }
     * })
     * 
    **/
    delete<T extends PneuDeleteArgs>(
      args: SelectSubset<T, PneuDeleteArgs>
    ): Prisma__PneuClient<PneuGetPayload<T>>

    /**
     * Update one Pneu.
     * @param {PneuUpdateArgs} args - Arguments to update one Pneu.
     * @example
     * // Update one Pneu
     * const pneu = await prisma.pneu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PneuUpdateArgs>(
      args: SelectSubset<T, PneuUpdateArgs>
    ): Prisma__PneuClient<PneuGetPayload<T>>

    /**
     * Delete zero or more Pneus.
     * @param {PneuDeleteManyArgs} args - Arguments to filter Pneus to delete.
     * @example
     * // Delete a few Pneus
     * const { count } = await prisma.pneu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PneuDeleteManyArgs>(
      args?: SelectSubset<T, PneuDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pneus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PneuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pneus
     * const pneu = await prisma.pneu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PneuUpdateManyArgs>(
      args: SelectSubset<T, PneuUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pneu.
     * @param {PneuUpsertArgs} args - Arguments to update or create a Pneu.
     * @example
     * // Update or create a Pneu
     * const pneu = await prisma.pneu.upsert({
     *   create: {
     *     // ... data to create a Pneu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pneu we want to update
     *   }
     * })
    **/
    upsert<T extends PneuUpsertArgs>(
      args: SelectSubset<T, PneuUpsertArgs>
    ): Prisma__PneuClient<PneuGetPayload<T>>

    /**
     * Count the number of Pneus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PneuCountArgs} args - Arguments to filter Pneus to count.
     * @example
     * // Count the number of Pneus
     * const count = await prisma.pneu.count({
     *   where: {
     *     // ... the filter for the Pneus we want to count
     *   }
     * })
    **/
    count<T extends PneuCountArgs>(
      args?: Subset<T, PneuCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PneuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pneu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PneuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PneuAggregateArgs>(args: Subset<T, PneuAggregateArgs>): PrismaPromise<GetPneuAggregateType<T>>

    /**
     * Group by Pneu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PneuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PneuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PneuGroupByArgs['orderBy'] }
        : { orderBy?: PneuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PneuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPneuGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pneu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PneuClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    engin<T extends EnginArgs= {}>(args?: Subset<T, EnginArgs>): Prisma__EnginClient<EnginGetPayload<T> | Null>;

    position<T extends PositionArgs= {}>(args?: Subset<T, PositionArgs>): Prisma__PositionClient<PositionGetPayload<T> | Null>;

    sorties<T extends Pneu$sortiesArgs= {}>(args?: Subset<T, Pneu$sortiesArgs>): PrismaPromise<Array<SortieGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pneu base type for findUnique actions
   */
  export type PneuFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Pneu
     */
    select?: PneuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PneuInclude | null
    /**
     * Filter, which Pneu to fetch.
     */
    where: PneuWhereUniqueInput
  }

  /**
   * Pneu findUnique
   */
  export interface PneuFindUniqueArgs extends PneuFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pneu findUniqueOrThrow
   */
  export type PneuFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pneu
     */
    select?: PneuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PneuInclude | null
    /**
     * Filter, which Pneu to fetch.
     */
    where: PneuWhereUniqueInput
  }


  /**
   * Pneu base type for findFirst actions
   */
  export type PneuFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Pneu
     */
    select?: PneuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PneuInclude | null
    /**
     * Filter, which Pneu to fetch.
     */
    where?: PneuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pneus to fetch.
     */
    orderBy?: Enumerable<PneuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pneus.
     */
    cursor?: PneuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pneus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pneus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pneus.
     */
    distinct?: Enumerable<PneuScalarFieldEnum>
  }

  /**
   * Pneu findFirst
   */
  export interface PneuFindFirstArgs extends PneuFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pneu findFirstOrThrow
   */
  export type PneuFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Pneu
     */
    select?: PneuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PneuInclude | null
    /**
     * Filter, which Pneu to fetch.
     */
    where?: PneuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pneus to fetch.
     */
    orderBy?: Enumerable<PneuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pneus.
     */
    cursor?: PneuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pneus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pneus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pneus.
     */
    distinct?: Enumerable<PneuScalarFieldEnum>
  }


  /**
   * Pneu findMany
   */
  export type PneuFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pneu
     */
    select?: PneuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PneuInclude | null
    /**
     * Filter, which Pneus to fetch.
     */
    where?: PneuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pneus to fetch.
     */
    orderBy?: Enumerable<PneuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pneus.
     */
    cursor?: PneuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pneus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pneus.
     */
    skip?: number
    distinct?: Enumerable<PneuScalarFieldEnum>
  }


  /**
   * Pneu create
   */
  export type PneuCreateArgs = {
    /**
     * Select specific fields to fetch from the Pneu
     */
    select?: PneuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PneuInclude | null
    /**
     * The data needed to create a Pneu.
     */
    data: XOR<PneuCreateInput, PneuUncheckedCreateInput>
  }


  /**
   * Pneu update
   */
  export type PneuUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pneu
     */
    select?: PneuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PneuInclude | null
    /**
     * The data needed to update a Pneu.
     */
    data: XOR<PneuUpdateInput, PneuUncheckedUpdateInput>
    /**
     * Choose, which Pneu to update.
     */
    where: PneuWhereUniqueInput
  }


  /**
   * Pneu updateMany
   */
  export type PneuUpdateManyArgs = {
    /**
     * The data used to update Pneus.
     */
    data: XOR<PneuUpdateManyMutationInput, PneuUncheckedUpdateManyInput>
    /**
     * Filter which Pneus to update
     */
    where?: PneuWhereInput
  }


  /**
   * Pneu upsert
   */
  export type PneuUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pneu
     */
    select?: PneuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PneuInclude | null
    /**
     * The filter to search for the Pneu to update in case it exists.
     */
    where: PneuWhereUniqueInput
    /**
     * In case the Pneu found by the `where` argument doesn't exist, create a new Pneu with this data.
     */
    create: XOR<PneuCreateInput, PneuUncheckedCreateInput>
    /**
     * In case the Pneu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PneuUpdateInput, PneuUncheckedUpdateInput>
  }


  /**
   * Pneu delete
   */
  export type PneuDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pneu
     */
    select?: PneuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PneuInclude | null
    /**
     * Filter which Pneu to delete.
     */
    where: PneuWhereUniqueInput
  }


  /**
   * Pneu deleteMany
   */
  export type PneuDeleteManyArgs = {
    /**
     * Filter which Pneus to delete
     */
    where?: PneuWhereInput
  }


  /**
   * Pneu.sorties
   */
  export type Pneu$sortiesArgs = {
    /**
     * Select specific fields to fetch from the Sortie
     */
    select?: SortieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SortieInclude | null
    where?: SortieWhereInput
    orderBy?: Enumerable<SortieOrderByWithRelationInput>
    cursor?: SortieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SortieScalarFieldEnum>
  }


  /**
   * Pneu without action
   */
  export type PneuArgs = {
    /**
     * Select specific fields to fetch from the Pneu
     */
    select?: PneuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PneuInclude | null
  }



  /**
   * Model Sortie
   */


  export type AggregateSortie = {
    _count: SortieCountAggregateOutputType | null
    _avg: SortieAvgAggregateOutputType | null
    _sum: SortieSumAggregateOutputType | null
    _min: SortieMinAggregateOutputType | null
    _max: SortieMaxAggregateOutputType | null
  }

  export type SortieAvgAggregateOutputType = {
    id: number | null
    pneuId: number | null
    chauffeurId: number | null
    kilometre: number | null
    statut: number | null
  }

  export type SortieSumAggregateOutputType = {
    id: number | null
    pneuId: number | null
    chauffeurId: number | null
    kilometre: number | null
    statut: number | null
  }

  export type SortieMinAggregateOutputType = {
    id: number | null
    date: Date | null
    pneuId: number | null
    chauffeurId: number | null
    kilometre: number | null
    motif: string | null
    statut: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SortieMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    pneuId: number | null
    chauffeurId: number | null
    kilometre: number | null
    motif: string | null
    statut: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SortieCountAggregateOutputType = {
    id: number
    date: number
    pneuId: number
    chauffeurId: number
    kilometre: number
    motif: number
    statut: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SortieAvgAggregateInputType = {
    id?: true
    pneuId?: true
    chauffeurId?: true
    kilometre?: true
    statut?: true
  }

  export type SortieSumAggregateInputType = {
    id?: true
    pneuId?: true
    chauffeurId?: true
    kilometre?: true
    statut?: true
  }

  export type SortieMinAggregateInputType = {
    id?: true
    date?: true
    pneuId?: true
    chauffeurId?: true
    kilometre?: true
    motif?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SortieMaxAggregateInputType = {
    id?: true
    date?: true
    pneuId?: true
    chauffeurId?: true
    kilometre?: true
    motif?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SortieCountAggregateInputType = {
    id?: true
    date?: true
    pneuId?: true
    chauffeurId?: true
    kilometre?: true
    motif?: true
    statut?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SortieAggregateArgs = {
    /**
     * Filter which Sortie to aggregate.
     */
    where?: SortieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sorties to fetch.
     */
    orderBy?: Enumerable<SortieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SortieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sorties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sorties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sorties
    **/
    _count?: true | SortieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SortieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SortieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SortieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SortieMaxAggregateInputType
  }

  export type GetSortieAggregateType<T extends SortieAggregateArgs> = {
        [P in keyof T & keyof AggregateSortie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSortie[P]>
      : GetScalarType<T[P], AggregateSortie[P]>
  }




  export type SortieGroupByArgs = {
    where?: SortieWhereInput
    orderBy?: Enumerable<SortieOrderByWithAggregationInput>
    by: SortieScalarFieldEnum[]
    having?: SortieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SortieCountAggregateInputType | true
    _avg?: SortieAvgAggregateInputType
    _sum?: SortieSumAggregateInputType
    _min?: SortieMinAggregateInputType
    _max?: SortieMaxAggregateInputType
  }


  export type SortieGroupByOutputType = {
    id: number
    date: Date
    pneuId: number | null
    chauffeurId: number | null
    kilometre: number
    motif: string
    statut: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: SortieCountAggregateOutputType | null
    _avg: SortieAvgAggregateOutputType | null
    _sum: SortieSumAggregateOutputType | null
    _min: SortieMinAggregateOutputType | null
    _max: SortieMaxAggregateOutputType | null
  }

  type GetSortieGroupByPayload<T extends SortieGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SortieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SortieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SortieGroupByOutputType[P]>
            : GetScalarType<T[P], SortieGroupByOutputType[P]>
        }
      >
    >


  export type SortieSelect = {
    id?: boolean
    date?: boolean
    pneu?: boolean | PneuArgs
    pneuId?: boolean
    chauffeur?: boolean | ChauffeurArgs
    chauffeurId?: boolean
    kilometre?: boolean
    motif?: boolean
    statut?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type SortieInclude = {
    pneu?: boolean | PneuArgs
    chauffeur?: boolean | ChauffeurArgs
  }

  export type SortieGetPayload<S extends boolean | null | undefined | SortieArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Sortie :
    S extends undefined ? never :
    S extends { include: any } & (SortieArgs | SortieFindManyArgs)
    ? Sortie  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'pneu' ? PneuGetPayload<S['include'][P]> | null :
        P extends 'chauffeur' ? ChauffeurGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (SortieArgs | SortieFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'pneu' ? PneuGetPayload<S['select'][P]> | null :
        P extends 'chauffeur' ? ChauffeurGetPayload<S['select'][P]> | null :  P extends keyof Sortie ? Sortie[P] : never
  } 
      : Sortie


  type SortieCountArgs = 
    Omit<SortieFindManyArgs, 'select' | 'include'> & {
      select?: SortieCountAggregateInputType | true
    }

  export interface SortieDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Sortie that matches the filter.
     * @param {SortieFindUniqueArgs} args - Arguments to find a Sortie
     * @example
     * // Get one Sortie
     * const sortie = await prisma.sortie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SortieFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SortieFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Sortie'> extends True ? Prisma__SortieClient<SortieGetPayload<T>> : Prisma__SortieClient<SortieGetPayload<T> | null, null>

    /**
     * Find one Sortie that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SortieFindUniqueOrThrowArgs} args - Arguments to find a Sortie
     * @example
     * // Get one Sortie
     * const sortie = await prisma.sortie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SortieFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SortieFindUniqueOrThrowArgs>
    ): Prisma__SortieClient<SortieGetPayload<T>>

    /**
     * Find the first Sortie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieFindFirstArgs} args - Arguments to find a Sortie
     * @example
     * // Get one Sortie
     * const sortie = await prisma.sortie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SortieFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SortieFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Sortie'> extends True ? Prisma__SortieClient<SortieGetPayload<T>> : Prisma__SortieClient<SortieGetPayload<T> | null, null>

    /**
     * Find the first Sortie that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieFindFirstOrThrowArgs} args - Arguments to find a Sortie
     * @example
     * // Get one Sortie
     * const sortie = await prisma.sortie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SortieFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SortieFindFirstOrThrowArgs>
    ): Prisma__SortieClient<SortieGetPayload<T>>

    /**
     * Find zero or more Sorties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sorties
     * const sorties = await prisma.sortie.findMany()
     * 
     * // Get first 10 Sorties
     * const sorties = await prisma.sortie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sortieWithIdOnly = await prisma.sortie.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SortieFindManyArgs>(
      args?: SelectSubset<T, SortieFindManyArgs>
    ): PrismaPromise<Array<SortieGetPayload<T>>>

    /**
     * Create a Sortie.
     * @param {SortieCreateArgs} args - Arguments to create a Sortie.
     * @example
     * // Create one Sortie
     * const Sortie = await prisma.sortie.create({
     *   data: {
     *     // ... data to create a Sortie
     *   }
     * })
     * 
    **/
    create<T extends SortieCreateArgs>(
      args: SelectSubset<T, SortieCreateArgs>
    ): Prisma__SortieClient<SortieGetPayload<T>>

    /**
     * Delete a Sortie.
     * @param {SortieDeleteArgs} args - Arguments to delete one Sortie.
     * @example
     * // Delete one Sortie
     * const Sortie = await prisma.sortie.delete({
     *   where: {
     *     // ... filter to delete one Sortie
     *   }
     * })
     * 
    **/
    delete<T extends SortieDeleteArgs>(
      args: SelectSubset<T, SortieDeleteArgs>
    ): Prisma__SortieClient<SortieGetPayload<T>>

    /**
     * Update one Sortie.
     * @param {SortieUpdateArgs} args - Arguments to update one Sortie.
     * @example
     * // Update one Sortie
     * const sortie = await prisma.sortie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SortieUpdateArgs>(
      args: SelectSubset<T, SortieUpdateArgs>
    ): Prisma__SortieClient<SortieGetPayload<T>>

    /**
     * Delete zero or more Sorties.
     * @param {SortieDeleteManyArgs} args - Arguments to filter Sorties to delete.
     * @example
     * // Delete a few Sorties
     * const { count } = await prisma.sortie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SortieDeleteManyArgs>(
      args?: SelectSubset<T, SortieDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sorties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sorties
     * const sortie = await prisma.sortie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SortieUpdateManyArgs>(
      args: SelectSubset<T, SortieUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Sortie.
     * @param {SortieUpsertArgs} args - Arguments to update or create a Sortie.
     * @example
     * // Update or create a Sortie
     * const sortie = await prisma.sortie.upsert({
     *   create: {
     *     // ... data to create a Sortie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sortie we want to update
     *   }
     * })
    **/
    upsert<T extends SortieUpsertArgs>(
      args: SelectSubset<T, SortieUpsertArgs>
    ): Prisma__SortieClient<SortieGetPayload<T>>

    /**
     * Count the number of Sorties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieCountArgs} args - Arguments to filter Sorties to count.
     * @example
     * // Count the number of Sorties
     * const count = await prisma.sortie.count({
     *   where: {
     *     // ... the filter for the Sorties we want to count
     *   }
     * })
    **/
    count<T extends SortieCountArgs>(
      args?: Subset<T, SortieCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SortieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sortie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SortieAggregateArgs>(args: Subset<T, SortieAggregateArgs>): PrismaPromise<GetSortieAggregateType<T>>

    /**
     * Group by Sortie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SortieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SortieGroupByArgs['orderBy'] }
        : { orderBy?: SortieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SortieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSortieGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Sortie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SortieClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pneu<T extends PneuArgs= {}>(args?: Subset<T, PneuArgs>): Prisma__PneuClient<PneuGetPayload<T> | Null>;

    chauffeur<T extends ChauffeurArgs= {}>(args?: Subset<T, ChauffeurArgs>): Prisma__ChauffeurClient<ChauffeurGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Sortie base type for findUnique actions
   */
  export type SortieFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Sortie
     */
    select?: SortieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SortieInclude | null
    /**
     * Filter, which Sortie to fetch.
     */
    where: SortieWhereUniqueInput
  }

  /**
   * Sortie findUnique
   */
  export interface SortieFindUniqueArgs extends SortieFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Sortie findUniqueOrThrow
   */
  export type SortieFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Sortie
     */
    select?: SortieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SortieInclude | null
    /**
     * Filter, which Sortie to fetch.
     */
    where: SortieWhereUniqueInput
  }


  /**
   * Sortie base type for findFirst actions
   */
  export type SortieFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Sortie
     */
    select?: SortieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SortieInclude | null
    /**
     * Filter, which Sortie to fetch.
     */
    where?: SortieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sorties to fetch.
     */
    orderBy?: Enumerable<SortieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sorties.
     */
    cursor?: SortieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sorties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sorties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sorties.
     */
    distinct?: Enumerable<SortieScalarFieldEnum>
  }

  /**
   * Sortie findFirst
   */
  export interface SortieFindFirstArgs extends SortieFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Sortie findFirstOrThrow
   */
  export type SortieFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Sortie
     */
    select?: SortieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SortieInclude | null
    /**
     * Filter, which Sortie to fetch.
     */
    where?: SortieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sorties to fetch.
     */
    orderBy?: Enumerable<SortieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sorties.
     */
    cursor?: SortieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sorties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sorties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sorties.
     */
    distinct?: Enumerable<SortieScalarFieldEnum>
  }


  /**
   * Sortie findMany
   */
  export type SortieFindManyArgs = {
    /**
     * Select specific fields to fetch from the Sortie
     */
    select?: SortieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SortieInclude | null
    /**
     * Filter, which Sorties to fetch.
     */
    where?: SortieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sorties to fetch.
     */
    orderBy?: Enumerable<SortieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sorties.
     */
    cursor?: SortieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sorties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sorties.
     */
    skip?: number
    distinct?: Enumerable<SortieScalarFieldEnum>
  }


  /**
   * Sortie create
   */
  export type SortieCreateArgs = {
    /**
     * Select specific fields to fetch from the Sortie
     */
    select?: SortieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SortieInclude | null
    /**
     * The data needed to create a Sortie.
     */
    data: XOR<SortieCreateInput, SortieUncheckedCreateInput>
  }


  /**
   * Sortie update
   */
  export type SortieUpdateArgs = {
    /**
     * Select specific fields to fetch from the Sortie
     */
    select?: SortieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SortieInclude | null
    /**
     * The data needed to update a Sortie.
     */
    data: XOR<SortieUpdateInput, SortieUncheckedUpdateInput>
    /**
     * Choose, which Sortie to update.
     */
    where: SortieWhereUniqueInput
  }


  /**
   * Sortie updateMany
   */
  export type SortieUpdateManyArgs = {
    /**
     * The data used to update Sorties.
     */
    data: XOR<SortieUpdateManyMutationInput, SortieUncheckedUpdateManyInput>
    /**
     * Filter which Sorties to update
     */
    where?: SortieWhereInput
  }


  /**
   * Sortie upsert
   */
  export type SortieUpsertArgs = {
    /**
     * Select specific fields to fetch from the Sortie
     */
    select?: SortieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SortieInclude | null
    /**
     * The filter to search for the Sortie to update in case it exists.
     */
    where: SortieWhereUniqueInput
    /**
     * In case the Sortie found by the `where` argument doesn't exist, create a new Sortie with this data.
     */
    create: XOR<SortieCreateInput, SortieUncheckedCreateInput>
    /**
     * In case the Sortie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SortieUpdateInput, SortieUncheckedUpdateInput>
  }


  /**
   * Sortie delete
   */
  export type SortieDeleteArgs = {
    /**
     * Select specific fields to fetch from the Sortie
     */
    select?: SortieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SortieInclude | null
    /**
     * Filter which Sortie to delete.
     */
    where: SortieWhereUniqueInput
  }


  /**
   * Sortie deleteMany
   */
  export type SortieDeleteManyArgs = {
    /**
     * Filter which Sorties to delete
     */
    where?: SortieWhereInput
  }


  /**
   * Sortie without action
   */
  export type SortieArgs = {
    /**
     * Select specific fields to fetch from the Sortie
     */
    select?: SortieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SortieInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ChauffeurScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    prenom: 'prenom',
    contact: 'contact',
    adresse: 'adresse',
    statut: 'statut',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChauffeurScalarFieldEnum = (typeof ChauffeurScalarFieldEnum)[keyof typeof ChauffeurScalarFieldEnum]


  export const EnginScalarFieldEnum: {
    id: 'id',
    immatriculation: 'immatriculation',
    marque: 'marque',
    model: 'model',
    statut: 'statut',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EnginScalarFieldEnum = (typeof EnginScalarFieldEnum)[keyof typeof EnginScalarFieldEnum]


  export const PneuScalarFieldEnum: {
    id: 'id',
    numero_serie: 'numero_serie',
    enginId: 'enginId',
    designation: 'designation',
    positionId: 'positionId',
    date_debut: 'date_debut',
    etat: 'etat',
    statut: 'statut',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PneuScalarFieldEnum = (typeof PneuScalarFieldEnum)[keyof typeof PneuScalarFieldEnum]


  export const PositionScalarFieldEnum: {
    id: 'id',
    designation: 'designation',
    statut: 'statut',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SortieScalarFieldEnum: {
    id: 'id',
    date: 'date',
    pneuId: 'pneuId',
    chauffeurId: 'chauffeurId',
    kilometre: 'kilometre',
    motif: 'motif',
    statut: 'statut',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SortieScalarFieldEnum = (typeof SortieScalarFieldEnum)[keyof typeof SortieScalarFieldEnum]


  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    phone: 'phone',
    name: 'name',
    password: 'password',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    phone?: StringFilter | string
    name?: StringNullableFilter | string | null
    password?: StringFilter | string
    isDeleted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    password?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: number
    phone?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    password?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    phone?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    password?: StringWithAggregatesFilter | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EnginWhereInput = {
    AND?: Enumerable<EnginWhereInput>
    OR?: Enumerable<EnginWhereInput>
    NOT?: Enumerable<EnginWhereInput>
    id?: IntFilter | number
    immatriculation?: StringFilter | string
    marque?: StringFilter | string
    model?: StringFilter | string
    pneus?: PneuListRelationFilter
    statut?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type EnginOrderByWithRelationInput = {
    id?: SortOrder
    immatriculation?: SortOrder
    marque?: SortOrder
    model?: SortOrder
    pneus?: PneuOrderByRelationAggregateInput
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnginWhereUniqueInput = {
    id?: number
  }

  export type EnginOrderByWithAggregationInput = {
    id?: SortOrder
    immatriculation?: SortOrder
    marque?: SortOrder
    model?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EnginCountOrderByAggregateInput
    _avg?: EnginAvgOrderByAggregateInput
    _max?: EnginMaxOrderByAggregateInput
    _min?: EnginMinOrderByAggregateInput
    _sum?: EnginSumOrderByAggregateInput
  }

  export type EnginScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EnginScalarWhereWithAggregatesInput>
    OR?: Enumerable<EnginScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EnginScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    immatriculation?: StringWithAggregatesFilter | string
    marque?: StringWithAggregatesFilter | string
    model?: StringWithAggregatesFilter | string
    statut?: IntWithAggregatesFilter | number
    isDeleted?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ChauffeurWhereInput = {
    AND?: Enumerable<ChauffeurWhereInput>
    OR?: Enumerable<ChauffeurWhereInput>
    NOT?: Enumerable<ChauffeurWhereInput>
    id?: IntFilter | number
    nom?: StringFilter | string
    prenom?: StringFilter | string
    contact?: StringFilter | string
    adresse?: StringFilter | string
    sorties?: SortieListRelationFilter
    statut?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ChauffeurOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    adresse?: SortOrder
    sorties?: SortieOrderByRelationAggregateInput
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChauffeurWhereUniqueInput = {
    id?: number
  }

  export type ChauffeurOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    adresse?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChauffeurCountOrderByAggregateInput
    _avg?: ChauffeurAvgOrderByAggregateInput
    _max?: ChauffeurMaxOrderByAggregateInput
    _min?: ChauffeurMinOrderByAggregateInput
    _sum?: ChauffeurSumOrderByAggregateInput
  }

  export type ChauffeurScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChauffeurScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChauffeurScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChauffeurScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nom?: StringWithAggregatesFilter | string
    prenom?: StringWithAggregatesFilter | string
    contact?: StringWithAggregatesFilter | string
    adresse?: StringWithAggregatesFilter | string
    statut?: IntWithAggregatesFilter | number
    isDeleted?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PositionWhereInput = {
    AND?: Enumerable<PositionWhereInput>
    OR?: Enumerable<PositionWhereInput>
    NOT?: Enumerable<PositionWhereInput>
    id?: IntFilter | number
    designation?: StringFilter | string
    pneus?: PneuListRelationFilter
    statut?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PositionOrderByWithRelationInput = {
    id?: SortOrder
    designation?: SortOrder
    pneus?: PneuOrderByRelationAggregateInput
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionWhereUniqueInput = {
    id?: number
  }

  export type PositionOrderByWithAggregationInput = {
    id?: SortOrder
    designation?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PositionCountOrderByAggregateInput
    _avg?: PositionAvgOrderByAggregateInput
    _max?: PositionMaxOrderByAggregateInput
    _min?: PositionMinOrderByAggregateInput
    _sum?: PositionSumOrderByAggregateInput
  }

  export type PositionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PositionScalarWhereWithAggregatesInput>
    OR?: Enumerable<PositionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PositionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    designation?: StringWithAggregatesFilter | string
    statut?: IntWithAggregatesFilter | number
    isDeleted?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PneuWhereInput = {
    AND?: Enumerable<PneuWhereInput>
    OR?: Enumerable<PneuWhereInput>
    NOT?: Enumerable<PneuWhereInput>
    id?: IntFilter | number
    numero_serie?: StringFilter | string
    engin?: XOR<EnginRelationFilter, EnginWhereInput> | null
    enginId?: IntNullableFilter | number | null
    designation?: StringFilter | string
    position?: XOR<PositionRelationFilter, PositionWhereInput> | null
    positionId?: IntNullableFilter | number | null
    date_debut?: DateTimeFilter | Date | string
    sorties?: SortieListRelationFilter
    etat?: StringFilter | string
    statut?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PneuOrderByWithRelationInput = {
    id?: SortOrder
    numero_serie?: SortOrder
    engin?: EnginOrderByWithRelationInput
    enginId?: SortOrder
    designation?: SortOrder
    position?: PositionOrderByWithRelationInput
    positionId?: SortOrder
    date_debut?: SortOrder
    sorties?: SortieOrderByRelationAggregateInput
    etat?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PneuWhereUniqueInput = {
    id?: number
    numero_serie?: string
  }

  export type PneuOrderByWithAggregationInput = {
    id?: SortOrder
    numero_serie?: SortOrder
    enginId?: SortOrder
    designation?: SortOrder
    positionId?: SortOrder
    date_debut?: SortOrder
    etat?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PneuCountOrderByAggregateInput
    _avg?: PneuAvgOrderByAggregateInput
    _max?: PneuMaxOrderByAggregateInput
    _min?: PneuMinOrderByAggregateInput
    _sum?: PneuSumOrderByAggregateInput
  }

  export type PneuScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PneuScalarWhereWithAggregatesInput>
    OR?: Enumerable<PneuScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PneuScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    numero_serie?: StringWithAggregatesFilter | string
    enginId?: IntNullableWithAggregatesFilter | number | null
    designation?: StringWithAggregatesFilter | string
    positionId?: IntNullableWithAggregatesFilter | number | null
    date_debut?: DateTimeWithAggregatesFilter | Date | string
    etat?: StringWithAggregatesFilter | string
    statut?: IntWithAggregatesFilter | number
    isDeleted?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SortieWhereInput = {
    AND?: Enumerable<SortieWhereInput>
    OR?: Enumerable<SortieWhereInput>
    NOT?: Enumerable<SortieWhereInput>
    id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    pneu?: XOR<PneuRelationFilter, PneuWhereInput> | null
    pneuId?: IntNullableFilter | number | null
    chauffeur?: XOR<ChauffeurRelationFilter, ChauffeurWhereInput> | null
    chauffeurId?: IntNullableFilter | number | null
    kilometre?: IntFilter | number
    motif?: StringFilter | string
    statut?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SortieOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    pneu?: PneuOrderByWithRelationInput
    pneuId?: SortOrder
    chauffeur?: ChauffeurOrderByWithRelationInput
    chauffeurId?: SortOrder
    kilometre?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SortieWhereUniqueInput = {
    id?: number
  }

  export type SortieOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    pneuId?: SortOrder
    chauffeurId?: SortOrder
    kilometre?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SortieCountOrderByAggregateInput
    _avg?: SortieAvgOrderByAggregateInput
    _max?: SortieMaxOrderByAggregateInput
    _min?: SortieMinOrderByAggregateInput
    _sum?: SortieSumOrderByAggregateInput
  }

  export type SortieScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SortieScalarWhereWithAggregatesInput>
    OR?: Enumerable<SortieScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SortieScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    pneuId?: IntNullableWithAggregatesFilter | number | null
    chauffeurId?: IntNullableWithAggregatesFilter | number | null
    kilometre?: IntWithAggregatesFilter | number
    motif?: StringWithAggregatesFilter | string
    statut?: IntWithAggregatesFilter | number
    isDeleted?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCreateInput = {
    phone: string
    name?: string | null
    password: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    phone: string
    name?: string | null
    password: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateManyMutationInput = {
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnginCreateInput = {
    immatriculation: string
    marque: string
    model: string
    pneus?: PneuCreateNestedManyWithoutEnginInput
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnginUncheckedCreateInput = {
    id?: number
    immatriculation: string
    marque: string
    model: string
    pneus?: PneuUncheckedCreateNestedManyWithoutEnginInput
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnginUpdateInput = {
    immatriculation?: StringFieldUpdateOperationsInput | string
    marque?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    pneus?: PneuUpdateManyWithoutEnginNestedInput
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnginUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    immatriculation?: StringFieldUpdateOperationsInput | string
    marque?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    pneus?: PneuUncheckedUpdateManyWithoutEnginNestedInput
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnginUpdateManyMutationInput = {
    immatriculation?: StringFieldUpdateOperationsInput | string
    marque?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnginUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    immatriculation?: StringFieldUpdateOperationsInput | string
    marque?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChauffeurCreateInput = {
    nom: string
    prenom: string
    contact: string
    adresse: string
    sorties?: SortieCreateNestedManyWithoutChauffeurInput
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChauffeurUncheckedCreateInput = {
    id?: number
    nom: string
    prenom: string
    contact: string
    adresse: string
    sorties?: SortieUncheckedCreateNestedManyWithoutChauffeurInput
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChauffeurUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    sorties?: SortieUpdateManyWithoutChauffeurNestedInput
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChauffeurUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    sorties?: SortieUncheckedUpdateManyWithoutChauffeurNestedInput
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChauffeurUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChauffeurUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionCreateInput = {
    designation: string
    pneus?: PneuCreateNestedManyWithoutPositionInput
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionUncheckedCreateInput = {
    id?: number
    designation: string
    pneus?: PneuUncheckedCreateNestedManyWithoutPositionInput
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionUpdateInput = {
    designation?: StringFieldUpdateOperationsInput | string
    pneus?: PneuUpdateManyWithoutPositionNestedInput
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    pneus?: PneuUncheckedUpdateManyWithoutPositionNestedInput
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUpdateManyMutationInput = {
    designation?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PneuCreateInput = {
    numero_serie: string
    engin?: EnginCreateNestedOneWithoutPneusInput
    designation: string
    position?: PositionCreateNestedOneWithoutPneusInput
    date_debut?: Date | string
    sorties?: SortieCreateNestedManyWithoutPneuInput
    etat: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PneuUncheckedCreateInput = {
    id?: number
    numero_serie: string
    enginId?: number | null
    designation: string
    positionId?: number | null
    date_debut?: Date | string
    sorties?: SortieUncheckedCreateNestedManyWithoutPneuInput
    etat: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PneuUpdateInput = {
    numero_serie?: StringFieldUpdateOperationsInput | string
    engin?: EnginUpdateOneWithoutPneusNestedInput
    designation?: StringFieldUpdateOperationsInput | string
    position?: PositionUpdateOneWithoutPneusNestedInput
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    sorties?: SortieUpdateManyWithoutPneuNestedInput
    etat?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PneuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_serie?: StringFieldUpdateOperationsInput | string
    enginId?: NullableIntFieldUpdateOperationsInput | number | null
    designation?: StringFieldUpdateOperationsInput | string
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    sorties?: SortieUncheckedUpdateManyWithoutPneuNestedInput
    etat?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PneuUpdateManyMutationInput = {
    numero_serie?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    etat?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PneuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_serie?: StringFieldUpdateOperationsInput | string
    enginId?: NullableIntFieldUpdateOperationsInput | number | null
    designation?: StringFieldUpdateOperationsInput | string
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    etat?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieCreateInput = {
    date?: Date | string
    pneu?: PneuCreateNestedOneWithoutSortiesInput
    chauffeur?: ChauffeurCreateNestedOneWithoutSortiesInput
    kilometre: number
    motif: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortieUncheckedCreateInput = {
    id?: number
    date?: Date | string
    pneuId?: number | null
    chauffeurId?: number | null
    kilometre: number
    motif: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortieUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    pneu?: PneuUpdateOneWithoutSortiesNestedInput
    chauffeur?: ChauffeurUpdateOneWithoutSortiesNestedInput
    kilometre?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    pneuId?: NullableIntFieldUpdateOperationsInput | number | null
    chauffeurId?: NullableIntFieldUpdateOperationsInput | number | null
    kilometre?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    kilometre?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    pneuId?: NullableIntFieldUpdateOperationsInput | number | null
    chauffeurId?: NullableIntFieldUpdateOperationsInput | number | null
    kilometre?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    password?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    password?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    password?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type PneuListRelationFilter = {
    every?: PneuWhereInput
    some?: PneuWhereInput
    none?: PneuWhereInput
  }

  export type PneuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnginCountOrderByAggregateInput = {
    id?: SortOrder
    immatriculation?: SortOrder
    marque?: SortOrder
    model?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnginAvgOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
  }

  export type EnginMaxOrderByAggregateInput = {
    id?: SortOrder
    immatriculation?: SortOrder
    marque?: SortOrder
    model?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnginMinOrderByAggregateInput = {
    id?: SortOrder
    immatriculation?: SortOrder
    marque?: SortOrder
    model?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnginSumOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
  }

  export type SortieListRelationFilter = {
    every?: SortieWhereInput
    some?: SortieWhereInput
    none?: SortieWhereInput
  }

  export type SortieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChauffeurCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    adresse?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChauffeurAvgOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
  }

  export type ChauffeurMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    adresse?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChauffeurMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    adresse?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChauffeurSumOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
  }

  export type PositionCountOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionAvgOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
  }

  export type PositionMaxOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionMinOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionSumOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
  }

  export type EnginRelationFilter = {
    is?: EnginWhereInput | null
    isNot?: EnginWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type PositionRelationFilter = {
    is?: PositionWhereInput | null
    isNot?: PositionWhereInput | null
  }

  export type PneuCountOrderByAggregateInput = {
    id?: SortOrder
    numero_serie?: SortOrder
    enginId?: SortOrder
    designation?: SortOrder
    positionId?: SortOrder
    date_debut?: SortOrder
    etat?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PneuAvgOrderByAggregateInput = {
    id?: SortOrder
    enginId?: SortOrder
    positionId?: SortOrder
    statut?: SortOrder
  }

  export type PneuMaxOrderByAggregateInput = {
    id?: SortOrder
    numero_serie?: SortOrder
    enginId?: SortOrder
    designation?: SortOrder
    positionId?: SortOrder
    date_debut?: SortOrder
    etat?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PneuMinOrderByAggregateInput = {
    id?: SortOrder
    numero_serie?: SortOrder
    enginId?: SortOrder
    designation?: SortOrder
    positionId?: SortOrder
    date_debut?: SortOrder
    etat?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PneuSumOrderByAggregateInput = {
    id?: SortOrder
    enginId?: SortOrder
    positionId?: SortOrder
    statut?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type PneuRelationFilter = {
    is?: PneuWhereInput | null
    isNot?: PneuWhereInput | null
  }

  export type ChauffeurRelationFilter = {
    is?: ChauffeurWhereInput | null
    isNot?: ChauffeurWhereInput | null
  }

  export type SortieCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    pneuId?: SortOrder
    chauffeurId?: SortOrder
    kilometre?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SortieAvgOrderByAggregateInput = {
    id?: SortOrder
    pneuId?: SortOrder
    chauffeurId?: SortOrder
    kilometre?: SortOrder
    statut?: SortOrder
  }

  export type SortieMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    pneuId?: SortOrder
    chauffeurId?: SortOrder
    kilometre?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SortieMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    pneuId?: SortOrder
    chauffeurId?: SortOrder
    kilometre?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SortieSumOrderByAggregateInput = {
    id?: SortOrder
    pneuId?: SortOrder
    chauffeurId?: SortOrder
    kilometre?: SortOrder
    statut?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PneuCreateNestedManyWithoutEnginInput = {
    create?: XOR<Enumerable<PneuCreateWithoutEnginInput>, Enumerable<PneuUncheckedCreateWithoutEnginInput>>
    connectOrCreate?: Enumerable<PneuCreateOrConnectWithoutEnginInput>
    connect?: Enumerable<PneuWhereUniqueInput>
  }

  export type PneuUncheckedCreateNestedManyWithoutEnginInput = {
    create?: XOR<Enumerable<PneuCreateWithoutEnginInput>, Enumerable<PneuUncheckedCreateWithoutEnginInput>>
    connectOrCreate?: Enumerable<PneuCreateOrConnectWithoutEnginInput>
    connect?: Enumerable<PneuWhereUniqueInput>
  }

  export type PneuUpdateManyWithoutEnginNestedInput = {
    create?: XOR<Enumerable<PneuCreateWithoutEnginInput>, Enumerable<PneuUncheckedCreateWithoutEnginInput>>
    connectOrCreate?: Enumerable<PneuCreateOrConnectWithoutEnginInput>
    upsert?: Enumerable<PneuUpsertWithWhereUniqueWithoutEnginInput>
    set?: Enumerable<PneuWhereUniqueInput>
    disconnect?: Enumerable<PneuWhereUniqueInput>
    delete?: Enumerable<PneuWhereUniqueInput>
    connect?: Enumerable<PneuWhereUniqueInput>
    update?: Enumerable<PneuUpdateWithWhereUniqueWithoutEnginInput>
    updateMany?: Enumerable<PneuUpdateManyWithWhereWithoutEnginInput>
    deleteMany?: Enumerable<PneuScalarWhereInput>
  }

  export type PneuUncheckedUpdateManyWithoutEnginNestedInput = {
    create?: XOR<Enumerable<PneuCreateWithoutEnginInput>, Enumerable<PneuUncheckedCreateWithoutEnginInput>>
    connectOrCreate?: Enumerable<PneuCreateOrConnectWithoutEnginInput>
    upsert?: Enumerable<PneuUpsertWithWhereUniqueWithoutEnginInput>
    set?: Enumerable<PneuWhereUniqueInput>
    disconnect?: Enumerable<PneuWhereUniqueInput>
    delete?: Enumerable<PneuWhereUniqueInput>
    connect?: Enumerable<PneuWhereUniqueInput>
    update?: Enumerable<PneuUpdateWithWhereUniqueWithoutEnginInput>
    updateMany?: Enumerable<PneuUpdateManyWithWhereWithoutEnginInput>
    deleteMany?: Enumerable<PneuScalarWhereInput>
  }

  export type SortieCreateNestedManyWithoutChauffeurInput = {
    create?: XOR<Enumerable<SortieCreateWithoutChauffeurInput>, Enumerable<SortieUncheckedCreateWithoutChauffeurInput>>
    connectOrCreate?: Enumerable<SortieCreateOrConnectWithoutChauffeurInput>
    connect?: Enumerable<SortieWhereUniqueInput>
  }

  export type SortieUncheckedCreateNestedManyWithoutChauffeurInput = {
    create?: XOR<Enumerable<SortieCreateWithoutChauffeurInput>, Enumerable<SortieUncheckedCreateWithoutChauffeurInput>>
    connectOrCreate?: Enumerable<SortieCreateOrConnectWithoutChauffeurInput>
    connect?: Enumerable<SortieWhereUniqueInput>
  }

  export type SortieUpdateManyWithoutChauffeurNestedInput = {
    create?: XOR<Enumerable<SortieCreateWithoutChauffeurInput>, Enumerable<SortieUncheckedCreateWithoutChauffeurInput>>
    connectOrCreate?: Enumerable<SortieCreateOrConnectWithoutChauffeurInput>
    upsert?: Enumerable<SortieUpsertWithWhereUniqueWithoutChauffeurInput>
    set?: Enumerable<SortieWhereUniqueInput>
    disconnect?: Enumerable<SortieWhereUniqueInput>
    delete?: Enumerable<SortieWhereUniqueInput>
    connect?: Enumerable<SortieWhereUniqueInput>
    update?: Enumerable<SortieUpdateWithWhereUniqueWithoutChauffeurInput>
    updateMany?: Enumerable<SortieUpdateManyWithWhereWithoutChauffeurInput>
    deleteMany?: Enumerable<SortieScalarWhereInput>
  }

  export type SortieUncheckedUpdateManyWithoutChauffeurNestedInput = {
    create?: XOR<Enumerable<SortieCreateWithoutChauffeurInput>, Enumerable<SortieUncheckedCreateWithoutChauffeurInput>>
    connectOrCreate?: Enumerable<SortieCreateOrConnectWithoutChauffeurInput>
    upsert?: Enumerable<SortieUpsertWithWhereUniqueWithoutChauffeurInput>
    set?: Enumerable<SortieWhereUniqueInput>
    disconnect?: Enumerable<SortieWhereUniqueInput>
    delete?: Enumerable<SortieWhereUniqueInput>
    connect?: Enumerable<SortieWhereUniqueInput>
    update?: Enumerable<SortieUpdateWithWhereUniqueWithoutChauffeurInput>
    updateMany?: Enumerable<SortieUpdateManyWithWhereWithoutChauffeurInput>
    deleteMany?: Enumerable<SortieScalarWhereInput>
  }

  export type PneuCreateNestedManyWithoutPositionInput = {
    create?: XOR<Enumerable<PneuCreateWithoutPositionInput>, Enumerable<PneuUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PneuCreateOrConnectWithoutPositionInput>
    connect?: Enumerable<PneuWhereUniqueInput>
  }

  export type PneuUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<Enumerable<PneuCreateWithoutPositionInput>, Enumerable<PneuUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PneuCreateOrConnectWithoutPositionInput>
    connect?: Enumerable<PneuWhereUniqueInput>
  }

  export type PneuUpdateManyWithoutPositionNestedInput = {
    create?: XOR<Enumerable<PneuCreateWithoutPositionInput>, Enumerable<PneuUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PneuCreateOrConnectWithoutPositionInput>
    upsert?: Enumerable<PneuUpsertWithWhereUniqueWithoutPositionInput>
    set?: Enumerable<PneuWhereUniqueInput>
    disconnect?: Enumerable<PneuWhereUniqueInput>
    delete?: Enumerable<PneuWhereUniqueInput>
    connect?: Enumerable<PneuWhereUniqueInput>
    update?: Enumerable<PneuUpdateWithWhereUniqueWithoutPositionInput>
    updateMany?: Enumerable<PneuUpdateManyWithWhereWithoutPositionInput>
    deleteMany?: Enumerable<PneuScalarWhereInput>
  }

  export type PneuUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<Enumerable<PneuCreateWithoutPositionInput>, Enumerable<PneuUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PneuCreateOrConnectWithoutPositionInput>
    upsert?: Enumerable<PneuUpsertWithWhereUniqueWithoutPositionInput>
    set?: Enumerable<PneuWhereUniqueInput>
    disconnect?: Enumerable<PneuWhereUniqueInput>
    delete?: Enumerable<PneuWhereUniqueInput>
    connect?: Enumerable<PneuWhereUniqueInput>
    update?: Enumerable<PneuUpdateWithWhereUniqueWithoutPositionInput>
    updateMany?: Enumerable<PneuUpdateManyWithWhereWithoutPositionInput>
    deleteMany?: Enumerable<PneuScalarWhereInput>
  }

  export type EnginCreateNestedOneWithoutPneusInput = {
    create?: XOR<EnginCreateWithoutPneusInput, EnginUncheckedCreateWithoutPneusInput>
    connectOrCreate?: EnginCreateOrConnectWithoutPneusInput
    connect?: EnginWhereUniqueInput
  }

  export type PositionCreateNestedOneWithoutPneusInput = {
    create?: XOR<PositionCreateWithoutPneusInput, PositionUncheckedCreateWithoutPneusInput>
    connectOrCreate?: PositionCreateOrConnectWithoutPneusInput
    connect?: PositionWhereUniqueInput
  }

  export type SortieCreateNestedManyWithoutPneuInput = {
    create?: XOR<Enumerable<SortieCreateWithoutPneuInput>, Enumerable<SortieUncheckedCreateWithoutPneuInput>>
    connectOrCreate?: Enumerable<SortieCreateOrConnectWithoutPneuInput>
    connect?: Enumerable<SortieWhereUniqueInput>
  }

  export type SortieUncheckedCreateNestedManyWithoutPneuInput = {
    create?: XOR<Enumerable<SortieCreateWithoutPneuInput>, Enumerable<SortieUncheckedCreateWithoutPneuInput>>
    connectOrCreate?: Enumerable<SortieCreateOrConnectWithoutPneuInput>
    connect?: Enumerable<SortieWhereUniqueInput>
  }

  export type EnginUpdateOneWithoutPneusNestedInput = {
    create?: XOR<EnginCreateWithoutPneusInput, EnginUncheckedCreateWithoutPneusInput>
    connectOrCreate?: EnginCreateOrConnectWithoutPneusInput
    upsert?: EnginUpsertWithoutPneusInput
    disconnect?: boolean
    delete?: boolean
    connect?: EnginWhereUniqueInput
    update?: XOR<EnginUpdateWithoutPneusInput, EnginUncheckedUpdateWithoutPneusInput>
  }

  export type PositionUpdateOneWithoutPneusNestedInput = {
    create?: XOR<PositionCreateWithoutPneusInput, PositionUncheckedCreateWithoutPneusInput>
    connectOrCreate?: PositionCreateOrConnectWithoutPneusInput
    upsert?: PositionUpsertWithoutPneusInput
    disconnect?: boolean
    delete?: boolean
    connect?: PositionWhereUniqueInput
    update?: XOR<PositionUpdateWithoutPneusInput, PositionUncheckedUpdateWithoutPneusInput>
  }

  export type SortieUpdateManyWithoutPneuNestedInput = {
    create?: XOR<Enumerable<SortieCreateWithoutPneuInput>, Enumerable<SortieUncheckedCreateWithoutPneuInput>>
    connectOrCreate?: Enumerable<SortieCreateOrConnectWithoutPneuInput>
    upsert?: Enumerable<SortieUpsertWithWhereUniqueWithoutPneuInput>
    set?: Enumerable<SortieWhereUniqueInput>
    disconnect?: Enumerable<SortieWhereUniqueInput>
    delete?: Enumerable<SortieWhereUniqueInput>
    connect?: Enumerable<SortieWhereUniqueInput>
    update?: Enumerable<SortieUpdateWithWhereUniqueWithoutPneuInput>
    updateMany?: Enumerable<SortieUpdateManyWithWhereWithoutPneuInput>
    deleteMany?: Enumerable<SortieScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SortieUncheckedUpdateManyWithoutPneuNestedInput = {
    create?: XOR<Enumerable<SortieCreateWithoutPneuInput>, Enumerable<SortieUncheckedCreateWithoutPneuInput>>
    connectOrCreate?: Enumerable<SortieCreateOrConnectWithoutPneuInput>
    upsert?: Enumerable<SortieUpsertWithWhereUniqueWithoutPneuInput>
    set?: Enumerable<SortieWhereUniqueInput>
    disconnect?: Enumerable<SortieWhereUniqueInput>
    delete?: Enumerable<SortieWhereUniqueInput>
    connect?: Enumerable<SortieWhereUniqueInput>
    update?: Enumerable<SortieUpdateWithWhereUniqueWithoutPneuInput>
    updateMany?: Enumerable<SortieUpdateManyWithWhereWithoutPneuInput>
    deleteMany?: Enumerable<SortieScalarWhereInput>
  }

  export type PneuCreateNestedOneWithoutSortiesInput = {
    create?: XOR<PneuCreateWithoutSortiesInput, PneuUncheckedCreateWithoutSortiesInput>
    connectOrCreate?: PneuCreateOrConnectWithoutSortiesInput
    connect?: PneuWhereUniqueInput
  }

  export type ChauffeurCreateNestedOneWithoutSortiesInput = {
    create?: XOR<ChauffeurCreateWithoutSortiesInput, ChauffeurUncheckedCreateWithoutSortiesInput>
    connectOrCreate?: ChauffeurCreateOrConnectWithoutSortiesInput
    connect?: ChauffeurWhereUniqueInput
  }

  export type PneuUpdateOneWithoutSortiesNestedInput = {
    create?: XOR<PneuCreateWithoutSortiesInput, PneuUncheckedCreateWithoutSortiesInput>
    connectOrCreate?: PneuCreateOrConnectWithoutSortiesInput
    upsert?: PneuUpsertWithoutSortiesInput
    disconnect?: boolean
    delete?: boolean
    connect?: PneuWhereUniqueInput
    update?: XOR<PneuUpdateWithoutSortiesInput, PneuUncheckedUpdateWithoutSortiesInput>
  }

  export type ChauffeurUpdateOneWithoutSortiesNestedInput = {
    create?: XOR<ChauffeurCreateWithoutSortiesInput, ChauffeurUncheckedCreateWithoutSortiesInput>
    connectOrCreate?: ChauffeurCreateOrConnectWithoutSortiesInput
    upsert?: ChauffeurUpsertWithoutSortiesInput
    disconnect?: boolean
    delete?: boolean
    connect?: ChauffeurWhereUniqueInput
    update?: XOR<ChauffeurUpdateWithoutSortiesInput, ChauffeurUncheckedUpdateWithoutSortiesInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type PneuCreateWithoutEnginInput = {
    numero_serie: string
    designation: string
    position?: PositionCreateNestedOneWithoutPneusInput
    date_debut?: Date | string
    sorties?: SortieCreateNestedManyWithoutPneuInput
    etat: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PneuUncheckedCreateWithoutEnginInput = {
    id?: number
    numero_serie: string
    designation: string
    positionId?: number | null
    date_debut?: Date | string
    sorties?: SortieUncheckedCreateNestedManyWithoutPneuInput
    etat: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PneuCreateOrConnectWithoutEnginInput = {
    where: PneuWhereUniqueInput
    create: XOR<PneuCreateWithoutEnginInput, PneuUncheckedCreateWithoutEnginInput>
  }

  export type PneuUpsertWithWhereUniqueWithoutEnginInput = {
    where: PneuWhereUniqueInput
    update: XOR<PneuUpdateWithoutEnginInput, PneuUncheckedUpdateWithoutEnginInput>
    create: XOR<PneuCreateWithoutEnginInput, PneuUncheckedCreateWithoutEnginInput>
  }

  export type PneuUpdateWithWhereUniqueWithoutEnginInput = {
    where: PneuWhereUniqueInput
    data: XOR<PneuUpdateWithoutEnginInput, PneuUncheckedUpdateWithoutEnginInput>
  }

  export type PneuUpdateManyWithWhereWithoutEnginInput = {
    where: PneuScalarWhereInput
    data: XOR<PneuUpdateManyMutationInput, PneuUncheckedUpdateManyWithoutPneusInput>
  }

  export type PneuScalarWhereInput = {
    AND?: Enumerable<PneuScalarWhereInput>
    OR?: Enumerable<PneuScalarWhereInput>
    NOT?: Enumerable<PneuScalarWhereInput>
    id?: IntFilter | number
    numero_serie?: StringFilter | string
    enginId?: IntNullableFilter | number | null
    designation?: StringFilter | string
    positionId?: IntNullableFilter | number | null
    date_debut?: DateTimeFilter | Date | string
    etat?: StringFilter | string
    statut?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SortieCreateWithoutChauffeurInput = {
    date?: Date | string
    pneu?: PneuCreateNestedOneWithoutSortiesInput
    kilometre: number
    motif: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortieUncheckedCreateWithoutChauffeurInput = {
    id?: number
    date?: Date | string
    pneuId?: number | null
    kilometre: number
    motif: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortieCreateOrConnectWithoutChauffeurInput = {
    where: SortieWhereUniqueInput
    create: XOR<SortieCreateWithoutChauffeurInput, SortieUncheckedCreateWithoutChauffeurInput>
  }

  export type SortieUpsertWithWhereUniqueWithoutChauffeurInput = {
    where: SortieWhereUniqueInput
    update: XOR<SortieUpdateWithoutChauffeurInput, SortieUncheckedUpdateWithoutChauffeurInput>
    create: XOR<SortieCreateWithoutChauffeurInput, SortieUncheckedCreateWithoutChauffeurInput>
  }

  export type SortieUpdateWithWhereUniqueWithoutChauffeurInput = {
    where: SortieWhereUniqueInput
    data: XOR<SortieUpdateWithoutChauffeurInput, SortieUncheckedUpdateWithoutChauffeurInput>
  }

  export type SortieUpdateManyWithWhereWithoutChauffeurInput = {
    where: SortieScalarWhereInput
    data: XOR<SortieUpdateManyMutationInput, SortieUncheckedUpdateManyWithoutSortiesInput>
  }

  export type SortieScalarWhereInput = {
    AND?: Enumerable<SortieScalarWhereInput>
    OR?: Enumerable<SortieScalarWhereInput>
    NOT?: Enumerable<SortieScalarWhereInput>
    id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    pneuId?: IntNullableFilter | number | null
    chauffeurId?: IntNullableFilter | number | null
    kilometre?: IntFilter | number
    motif?: StringFilter | string
    statut?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PneuCreateWithoutPositionInput = {
    numero_serie: string
    engin?: EnginCreateNestedOneWithoutPneusInput
    designation: string
    date_debut?: Date | string
    sorties?: SortieCreateNestedManyWithoutPneuInput
    etat: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PneuUncheckedCreateWithoutPositionInput = {
    id?: number
    numero_serie: string
    enginId?: number | null
    designation: string
    date_debut?: Date | string
    sorties?: SortieUncheckedCreateNestedManyWithoutPneuInput
    etat: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PneuCreateOrConnectWithoutPositionInput = {
    where: PneuWhereUniqueInput
    create: XOR<PneuCreateWithoutPositionInput, PneuUncheckedCreateWithoutPositionInput>
  }

  export type PneuUpsertWithWhereUniqueWithoutPositionInput = {
    where: PneuWhereUniqueInput
    update: XOR<PneuUpdateWithoutPositionInput, PneuUncheckedUpdateWithoutPositionInput>
    create: XOR<PneuCreateWithoutPositionInput, PneuUncheckedCreateWithoutPositionInput>
  }

  export type PneuUpdateWithWhereUniqueWithoutPositionInput = {
    where: PneuWhereUniqueInput
    data: XOR<PneuUpdateWithoutPositionInput, PneuUncheckedUpdateWithoutPositionInput>
  }

  export type PneuUpdateManyWithWhereWithoutPositionInput = {
    where: PneuScalarWhereInput
    data: XOR<PneuUpdateManyMutationInput, PneuUncheckedUpdateManyWithoutPneusInput>
  }

  export type EnginCreateWithoutPneusInput = {
    immatriculation: string
    marque: string
    model: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnginUncheckedCreateWithoutPneusInput = {
    id?: number
    immatriculation: string
    marque: string
    model: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnginCreateOrConnectWithoutPneusInput = {
    where: EnginWhereUniqueInput
    create: XOR<EnginCreateWithoutPneusInput, EnginUncheckedCreateWithoutPneusInput>
  }

  export type PositionCreateWithoutPneusInput = {
    designation: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionUncheckedCreateWithoutPneusInput = {
    id?: number
    designation: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionCreateOrConnectWithoutPneusInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutPneusInput, PositionUncheckedCreateWithoutPneusInput>
  }

  export type SortieCreateWithoutPneuInput = {
    date?: Date | string
    chauffeur?: ChauffeurCreateNestedOneWithoutSortiesInput
    kilometre: number
    motif: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortieUncheckedCreateWithoutPneuInput = {
    id?: number
    date?: Date | string
    chauffeurId?: number | null
    kilometre: number
    motif: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortieCreateOrConnectWithoutPneuInput = {
    where: SortieWhereUniqueInput
    create: XOR<SortieCreateWithoutPneuInput, SortieUncheckedCreateWithoutPneuInput>
  }

  export type EnginUpsertWithoutPneusInput = {
    update: XOR<EnginUpdateWithoutPneusInput, EnginUncheckedUpdateWithoutPneusInput>
    create: XOR<EnginCreateWithoutPneusInput, EnginUncheckedCreateWithoutPneusInput>
  }

  export type EnginUpdateWithoutPneusInput = {
    immatriculation?: StringFieldUpdateOperationsInput | string
    marque?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnginUncheckedUpdateWithoutPneusInput = {
    id?: IntFieldUpdateOperationsInput | number
    immatriculation?: StringFieldUpdateOperationsInput | string
    marque?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUpsertWithoutPneusInput = {
    update: XOR<PositionUpdateWithoutPneusInput, PositionUncheckedUpdateWithoutPneusInput>
    create: XOR<PositionCreateWithoutPneusInput, PositionUncheckedCreateWithoutPneusInput>
  }

  export type PositionUpdateWithoutPneusInput = {
    designation?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUncheckedUpdateWithoutPneusInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieUpsertWithWhereUniqueWithoutPneuInput = {
    where: SortieWhereUniqueInput
    update: XOR<SortieUpdateWithoutPneuInput, SortieUncheckedUpdateWithoutPneuInput>
    create: XOR<SortieCreateWithoutPneuInput, SortieUncheckedCreateWithoutPneuInput>
  }

  export type SortieUpdateWithWhereUniqueWithoutPneuInput = {
    where: SortieWhereUniqueInput
    data: XOR<SortieUpdateWithoutPneuInput, SortieUncheckedUpdateWithoutPneuInput>
  }

  export type SortieUpdateManyWithWhereWithoutPneuInput = {
    where: SortieScalarWhereInput
    data: XOR<SortieUpdateManyMutationInput, SortieUncheckedUpdateManyWithoutSortiesInput>
  }

  export type PneuCreateWithoutSortiesInput = {
    numero_serie: string
    engin?: EnginCreateNestedOneWithoutPneusInput
    designation: string
    position?: PositionCreateNestedOneWithoutPneusInput
    date_debut?: Date | string
    etat: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PneuUncheckedCreateWithoutSortiesInput = {
    id?: number
    numero_serie: string
    enginId?: number | null
    designation: string
    positionId?: number | null
    date_debut?: Date | string
    etat: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PneuCreateOrConnectWithoutSortiesInput = {
    where: PneuWhereUniqueInput
    create: XOR<PneuCreateWithoutSortiesInput, PneuUncheckedCreateWithoutSortiesInput>
  }

  export type ChauffeurCreateWithoutSortiesInput = {
    nom: string
    prenom: string
    contact: string
    adresse: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChauffeurUncheckedCreateWithoutSortiesInput = {
    id?: number
    nom: string
    prenom: string
    contact: string
    adresse: string
    statut?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChauffeurCreateOrConnectWithoutSortiesInput = {
    where: ChauffeurWhereUniqueInput
    create: XOR<ChauffeurCreateWithoutSortiesInput, ChauffeurUncheckedCreateWithoutSortiesInput>
  }

  export type PneuUpsertWithoutSortiesInput = {
    update: XOR<PneuUpdateWithoutSortiesInput, PneuUncheckedUpdateWithoutSortiesInput>
    create: XOR<PneuCreateWithoutSortiesInput, PneuUncheckedCreateWithoutSortiesInput>
  }

  export type PneuUpdateWithoutSortiesInput = {
    numero_serie?: StringFieldUpdateOperationsInput | string
    engin?: EnginUpdateOneWithoutPneusNestedInput
    designation?: StringFieldUpdateOperationsInput | string
    position?: PositionUpdateOneWithoutPneusNestedInput
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    etat?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PneuUncheckedUpdateWithoutSortiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_serie?: StringFieldUpdateOperationsInput | string
    enginId?: NullableIntFieldUpdateOperationsInput | number | null
    designation?: StringFieldUpdateOperationsInput | string
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    etat?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChauffeurUpsertWithoutSortiesInput = {
    update: XOR<ChauffeurUpdateWithoutSortiesInput, ChauffeurUncheckedUpdateWithoutSortiesInput>
    create: XOR<ChauffeurCreateWithoutSortiesInput, ChauffeurUncheckedCreateWithoutSortiesInput>
  }

  export type ChauffeurUpdateWithoutSortiesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChauffeurUncheckedUpdateWithoutSortiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PneuUpdateWithoutEnginInput = {
    numero_serie?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    position?: PositionUpdateOneWithoutPneusNestedInput
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    sorties?: SortieUpdateManyWithoutPneuNestedInput
    etat?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PneuUncheckedUpdateWithoutEnginInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_serie?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    sorties?: SortieUncheckedUpdateManyWithoutPneuNestedInput
    etat?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PneuUncheckedUpdateManyWithoutPneusInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_serie?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    etat?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieUpdateWithoutChauffeurInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    pneu?: PneuUpdateOneWithoutSortiesNestedInput
    kilometre?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieUncheckedUpdateWithoutChauffeurInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    pneuId?: NullableIntFieldUpdateOperationsInput | number | null
    kilometre?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieUncheckedUpdateManyWithoutSortiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    pneuId?: NullableIntFieldUpdateOperationsInput | number | null
    kilometre?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PneuUpdateWithoutPositionInput = {
    numero_serie?: StringFieldUpdateOperationsInput | string
    engin?: EnginUpdateOneWithoutPneusNestedInput
    designation?: StringFieldUpdateOperationsInput | string
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    sorties?: SortieUpdateManyWithoutPneuNestedInput
    etat?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PneuUncheckedUpdateWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_serie?: StringFieldUpdateOperationsInput | string
    enginId?: NullableIntFieldUpdateOperationsInput | number | null
    designation?: StringFieldUpdateOperationsInput | string
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    sorties?: SortieUncheckedUpdateManyWithoutPneuNestedInput
    etat?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieUpdateWithoutPneuInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    chauffeur?: ChauffeurUpdateOneWithoutSortiesNestedInput
    kilometre?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortieUncheckedUpdateWithoutPneuInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    chauffeurId?: NullableIntFieldUpdateOperationsInput | number | null
    kilometre?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}